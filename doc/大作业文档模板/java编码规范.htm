 <HTML>
<HEAD><meta http-equiv="Content-Type" content="text/html; charset=utf-8"> <meta name="filetype" content="example"> 
	<META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0">
	<META NAME="ProgId" CONTENT=FRONTPAGE.EDITOR.DOCUMENT>
    <link rel="stylesheet" type="text/css" href="images/rop.css">
	<TITLE>Java Programming Guidelines</TITLE> 
	
</HEAD>
<BODY>

 
 
<table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td valign="top">

<script language="JavaScript">
<!--

//Tell the TreePath to update itself
var thePath = "";
var type = typeof parent.ory_button;
if (type != "undefined") {
	 type = typeof parent.ory_button.getTreePath();
	 if (type != "undefined") {
	 	 thePath = parent.ory_button.getTreePath();
	 }
}
document.write(thePath);
-->
</script>

 


 

<H1 ALIGN=CENTER CLASS=BANNER><A NAME="XE_Java_Programming_Guidelines"></a><A NAME="XE_Programming_Guidelines_document__Java_Programming_Guidelines"></a> 
				<rpw name="PresentationName">Java Programming Guidelines</rpw>
			</H1> <p>Copyright &copy; 1999 Scott Ambler, Ambysoft, Inc.</p> <p>The Java Coding Guidelines are provided under license from Scott Ambler, Ambysoft Inc., www.ambysoft.com. </p> 
	<HR ALIGN=LEFT>
	<H1><A NAME="Top"><font size="4">Contents</font></a></H1> 
<p style="line-height: 100%"><b><font size="2" face="Arial">1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</font><a HREF="#1    Introduction"><font size="2" face="Arial">Introduction<br>
</font></a>&nbsp;&nbsp;&nbsp;<font size="2" face="Arial">&nbsp;&nbsp;&nbsp;&nbsp;
</font></b><font size="2" face="Arial">1.1&nbsp;&nbsp;<b>&nbsp; </b></font><a HREF="#1.1    The First and Last Guideline"><font face="Arial" size="2">The
first and last guideline</font></a> 
<p><b><font face="Arial" size="2">2&nbsp;&nbsp;&nbsp; </font><A HREF="#Coding Standards"><font face="Arial" size="2">Coding Standards<br>
</font></a>&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp; </font></b><font face="Arial" size="2">2.1&nbsp;<b>&nbsp;&nbsp;
</b></font><A HREF="#Naming conventions"><font face="Arial" size="2">Naming conventions<br>
</font></a>
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp; 2.2&nbsp;&nbsp;&nbsp;</font>
<A HREF="#Documentation conventions"><font face="Arial" size="2">Documentation conventions<br>
</font></a> 
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2.2.1&nbsp; </font><A HREF="#Types of Java Comments"><font face="Arial" size="2">Types of Java comments<br>
</font></a>
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2.2.2&nbsp; </font><A HREF="#A Quick Overview of javadoc"><font face="Arial" size="2">A quick overview of <i>javadoc</i></font></a>
<font face="Arial" size="2">&nbsp;&nbsp;</font>
<p><b><font face="Arial" size="2">3&nbsp;&nbsp;&nbsp; </font><A HREF="#Standards For Member Functions"><font face="Arial" size="2">Standards for
Member Functions<br>
</font></a>&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp; </font></b><font face="Arial" size="2">3.1&nbsp;&nbsp;&nbsp;<b>
</b></font><A HREF="#Naming Member Functions"><font face="Arial" size="2">Naming member functions<br>
</font></a> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font face="Arial" size="2">3.1.1&nbsp;&nbsp;&nbsp;
</font><A HREF="#Naming Accessor Member Functions"><font face="Arial" size="2">Naming accessor member functions<br>
</font></a> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font face="Arial" size="2">3.1.1.1&nbsp;&nbsp;&nbsp; </font><A HREF="#Getters"><font face="Arial" size="2">Getters<br>
</font></a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font face="Arial" size="2">3.1.1.2&nbsp;&nbsp;&nbsp; </font><A HREF="#Setters"><font face="Arial" size="2">Setters<br>
</font></a>
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp; 3.2&nbsp;&nbsp;&nbsp;
</font><A HREF="#Constructors"><font face="Arial" size="2">Naming constructors<br>
</font></a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font face="Arial" size="2">3.3&nbsp;&nbsp;&nbsp;
</font><A HREF="#Member Function Visibility"><font face="Arial" size="2">Member function visibility<br>
</font></a>&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;
3.4&nbsp;&nbsp;&nbsp; </font><A HREF="#Documenting Member Functions"><font face="Arial" size="2">Documenting member functions<br>
</font></a>
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#3.4.1    The member function header">3.4.1&nbsp;&nbsp;&nbsp; The member function header</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#3.4.2    Internal documentation">3.4.2&nbsp;&nbsp;&nbsp; Internal documentation</a><br>
</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font face="Arial" size="2">3.5&nbsp;&nbsp;&nbsp;
</font><A HREF="#Techniques for Writing Clean Code"><font face="Arial" size="2">Techniques for writing clean code<br>
</font></a>
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#3.5.1    Document Your Code">3.5.1&nbsp;&nbsp;&nbsp; Document your
code</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#3.5.2    Paragraph or indent your code">3.5.2&nbsp;&nbsp;&nbsp; Paragraph or indent your code</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#3.5.3    Use whitespace in your code">3.5.3&nbsp;&nbsp;&nbsp; Use whitespace in your code</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#3.5.4   Follow the 30-second rule">3.5.4&nbsp;&nbsp;&nbsp; Follow the 30-second rule</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#3.5.5    Write short, single command lines">3.5.5&nbsp;&nbsp;&nbsp; Write short, single command lines</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#3.5.6    Specify the order of operations">3.5.6&nbsp;&nbsp;&nbsp; Specify the order of operations</a></font>
</p>
<b><font face="Arial" size="2">4&nbsp;&nbsp;&nbsp; </font></b><A HREF="#Standards For Fields"><b><font face="Arial" size="2">Standards for
Fields and Properties<br>
</font></b></a> 
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2"><b>&nbsp;&nbsp; </b>4.1&nbsp;&nbsp;&nbsp;</font>
<A HREF="#Naming Fields"><font face="Arial" size="2">Naming fields<br>
</font></a> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font face="Arial" size="2">4.1.1&nbsp;&nbsp;&nbsp;
</font><A HREF="#Naming Components"><font face="Arial" size="2">Naming components
(widgets)<br>
</font></a>
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#4.1.1.1    Alternative for naming components: Hungarian notation">4.1.1.1&nbsp;&nbsp;&nbsp; Alternative for naming components: Hungarian notation</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#4.1.1.2    Alternative for naming components: postfix-Hungarian notation">4.1.1.2&nbsp;&nbsp;&nbsp;&nbsp;Alternative for naming components:
postfix-Hungarian notation</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#4.1.1.3    Set component name standards">4.1.1.3&nbsp;&nbsp;&nbsp;&nbsp;Set component name standards</a><br>
</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font face="Arial" size="2">4.1.2&nbsp;&nbsp;&nbsp;
</font><A HREF="#Naming Constants"><font face="Arial" size="2">Naming constants<br>
</font></a>
<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
4.1.3&nbsp;&nbsp;&nbsp; </font><A HREF="#Naming Collections"><font face="Arial" size="2">Naming collections<br>
</font></a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font face="Arial" size="2">4.2&nbsp;&nbsp;&nbsp;
</font><A HREF="#Field Visibility"><font face="Arial" size="2">Field visibility<br>
</font></a>
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#4.2.1    Do not &quot;hide&quot; names">4.2.1&nbsp;&nbsp;&nbsp; Do not &quot;hide&quot; names</a><br>
</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font face="Arial" size="2">4.3&nbsp;&nbsp;&nbsp;
</font><A HREF="#Documenting a Field"><font face="Arial" size="2">Documenting a field<br>
</font></a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font face="Arial" size="2">4.4&nbsp;&nbsp;&nbsp;
</font><A HREF="#Using Accessor Member Functions"><font face="Arial" size="2">Using accessor member functions<br>
</font></a>&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#4.4.1    Why use accessors?">4.4.1&nbsp;&nbsp;&nbsp; Why use accessors?</a></font>&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
</font>&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#4.4.1.1    When not to use accessors">4.4.1.1&nbsp;&nbsp; When not to use accessors</a><br>
</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font face="Arial" size="2">4.4.2&nbsp;&nbsp;&nbsp;
</font><A HREF="#Naming Accessors"><font face="Arial" size="2">Naming accessors<br>
</font></a>
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#4.4.3    Advanced techniques for accessors">
4.4.3&nbsp;&nbsp;&nbsp; Advanced techniques for accessors</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#4.4.3.1    Lazy initialization">4.4.3.1&nbsp;&nbsp;&nbsp; Lazy initialization</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a HREF="#4.4.3.2    Accessors for constants">4.4.3.2&nbsp;&nbsp;&nbsp;&nbsp;</a></font><a HREF="#4.4.3.2    Accessors for constants"><font face="Arial" size="2">Accessors for constants
</font></a>
<font face="Arial" size="2"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a HREF="#4.4.3.3    Accessors for collections">4.4.3.3&nbsp;&nbsp;&nbsp;&nbsp;</a></font><a HREF="#4.4.3.3    Accessors for collections"><font face="Arial" size="2">Accessors for collections<br>
</font></a>
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a HREF="#4.4.3.4    Accessing several fields simultaneously">4.4.3.4&nbsp;&nbsp;&nbsp;
</a></font><a HREF="#4.4.3.4    Accessing several fields simultaneously"><font face="Arial" size="2">Accessing several fields simultaneously
</font></a>
<font face="Arial" size="2">&nbsp;&nbsp;</font><font face="Arial" size="2"><br></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font face="Arial" size="2"><a HREF="#4.5    Visibility of accessors">4.5&nbsp;&nbsp;&nbsp;
</a></font><a HREF="#4.5    Visibility of accessors"><font face="Arial" size="2">Visibility of accessors<br>
</font></a>
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp; <a href="#4.6    Always initialize static fields">4.6&nbsp;&nbsp;&nbsp;
Always initialize static fields</a></font>
<p><b><font face="Arial" size="2">5&nbsp;&nbsp;&nbsp; </font></b><A HREF="#5    Standards for Local Variables"><b><font face="Arial" size="2">Standards for
Local Variables<br>
</font></b></a> 
&nbsp;&nbsp;&nbsp;<b><font face="Arial" size="2">&nbsp;</font><font size="2"><font face="Arial">&nbsp;
</font></font></b><font size="2"><a HREF="#5.1&nbsp;&nbsp;&nbsp; Naming local variables"><font face="Arial">5.1&nbsp;&nbsp;&nbsp;</font>
 <font face="Arial" size="2">Naming local variables<br>
</font></a> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font face="Arial" size="2">&nbsp;&nbsp;&nbsp;</font> <font face="Arial" size="2"><a HREF="#5.1.1    Naming streams">5.1.1&nbsp;&nbsp;&nbsp;
</a></font><a HREF="#5.1.1    Naming streams"><font face="Arial" size="2">Naming streams<br>
</font></a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; <font face="Arial" size="2">5.1.2&nbsp;&nbsp;&nbsp; </font><A HREF="#Naming Loop Counters"><font face="Arial" size="2">Naming loop counters<br>
</font></a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;
&nbsp;&nbsp; <font face="Arial" size="2">5.1.3&nbsp;&nbsp;&nbsp;
</font><A HREF="#Naming Exception Objects"><font face="Arial" size="2">Naming exception objects<br>
</font></a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font face="Arial">5.2&nbsp;&nbsp;</font>
<A HREF="#Declaring and Documenting Local Variables"><font face="Arial" size="2">Declaring and documenting local variables<br>
</font></a>
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; <a href="#5.2.1    General comments about declaration">5.2.1&nbsp;&nbsp;&nbsp;&nbsp; General comments about declaration</a></font>
</font>
<p><b><font face="Arial" size="2">6&nbsp;&nbsp;&nbsp; </font><A HREF="#Parameters to Member Functions"><font face="Arial" size="2">Standards for
Parameters to Member Functions<br>
</font></a>&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp; </font></b><font face="Arial" size="2">6.1&nbsp;&nbsp;&nbsp;</font>
<A HREF="#Naming Parameters"><font face="Arial" size="2">Naming parameters<br>
</font></a>
<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6.2&nbsp;&nbsp;&nbsp;
</font><A HREF="#Documenting Parameters"><font face="Arial" size="2">Documenting parameters<br>
</font></a>
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#6.2.1    Use interfaces for parameter types">6.2.1&nbsp;&nbsp;&nbsp; Use interfaces for parameter types</a></font><p><b><font face="Arial" size="2">7&nbsp;&nbsp;&nbsp; </font></b><A HREF="#Standards For Classes, Interfaces, Packages and Compilation Units"><b><font face="Arial" size="2">Standards for
Classes, Interfaces, Packages, and Compilation Units<br>
</font></b></a>&nbsp;&nbsp;&nbsp;<font face="Arial" size="2"><b>&nbsp;&nbsp;
</b>7.1&nbsp;&nbsp;&nbsp; </font><A HREF="#Standards for Classes"><font face="Arial" size="2">Standards for classes<br>
</font></a> 
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
7.1.1&nbsp;&nbsp;&nbsp; </font><A HREF="#Naming Classes"><font face="Arial" size="2">Naming classes<br>
</font></a>
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
7.1.2&nbsp;&nbsp;&nbsp; </font><A HREF="#Documenting a Class"><font face="Arial" size="2">Documenting a class<br>
</font></a>
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
7.1.3&nbsp;&nbsp;&nbsp; </font><A HREF="#Class Declarations"><font face="Arial" size="2">Class declarations<br>
</font></a>
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
7.1.4&nbsp;&nbsp;&nbsp; </font><A HREF="#Minimize the Public and Protected Interface"><font face="Arial" size="2">Minimize the public and protected interface<br>
</font></a>
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#7.1.4.1    Define the public interface first">7.1.4.1&nbsp;&nbsp;&nbsp; Define the public interface first</a><br>
</font>&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;
7.2&nbsp;&nbsp;&nbsp;&nbsp; </font><A HREF="#Standards for Interfaces"><font face="Arial" size="2">Standards for interfaces<br>
</font></a> 
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
7.2.1&nbsp;&nbsp;&nbsp; </font><A HREF="#Naming Interfaces"><font face="Arial" size="2">Naming interfaces<br>
</font></a>
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#7.2.1.1    Alternative">7.2.1.1&nbsp;&nbsp;&nbsp; Alternative<br>
</a></font>&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
7.2.2&nbsp;&nbsp;&nbsp; </font><A HREF="#Documenting Interfaces"><font face="Arial" size="2">Documenting interfaces<br>
</font></a>
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;
7.3&nbsp;&nbsp;&nbsp;&nbsp; </font><A HREF="#Standards for Packages"><font face="Arial" size="2">Standards for packages<br>
</font></a> 
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
7.3.1&nbsp;&nbsp;&nbsp; </font><A HREF="#Naming Packages"><font face="Arial" size="2">Naming packages<br>
</font></a>
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
7.3.2&nbsp;&nbsp;&nbsp; </font><A HREF="#Documenting Packages"><font face="Arial" size="2">Documenting
packages<br>
</font></a>&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;
7.4&nbsp;&nbsp;&nbsp;&nbsp; </font><A HREF="#Standards for Compilation Units"><font face="Arial" size="2">Standards for compilation units<br>
</font></a> 
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
7.4.1&nbsp;&nbsp;&nbsp; </font><A HREF="#Naming Compilation Units"><font face="Arial" size="2">Naming compilations units<br>
</font></a>
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
7.4.2&nbsp;&nbsp;&nbsp; </font><A HREF="#Documenting Compilation Units"><font face="Arial" size="2">Documenting compilation units</font></a>
<p><b><font face="Arial" size="2">8&nbsp;&nbsp;&nbsp; </font></b><A HREF="#Error Handling and Exceptions"><b><font face="Arial" size="2">Error
Handling and Exceptions</font></b></a>
</p>
<b><font face="Arial" size="2">9&nbsp;&nbsp;&nbsp; </font></b><A HREF="#Miscellaneous"><b><font face="Arial" size="2">Miscellaneous
Standards and Issues<br>
</font></b></a> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font face="Arial" size="2"><a HREF="#9.1    Reusing">9.1&nbsp;&nbsp;&nbsp;</a></font>
<a HREF="#9.1    Reusing"> <font face="Arial" size="2">Reusing<br>
</font></a>
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp; 9.2&nbsp;&nbsp;&nbsp;
</font><A HREF="#Importing Classes"><font face="Arial" size="2">Importing classes<br>
</font></a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font face="Arial" size="2">9.3</font>&nbsp;&nbsp;&nbsp;
<A HREF="#Optimizing Java Code"><font face="Arial" size="2">Optimizing Java code<br>
</font></a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font face="Arial" size="2">9.4&nbsp;&nbsp;&nbsp;</font>
<A HREF="#Writing Java Test Harnesses"><font face="Arial" size="2">Writing Java test harnesses</font></a>
<p><b><font face="Arial" size="2">10&nbsp;&nbsp;&nbsp; </font></b><A HREF="#Patterns of Success"><b><font face="Arial" size="2">Patterns of
Success<br>
</font></b></a>
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2"><b>&nbsp;&nbsp;&nbsp;&nbsp;</b><a href="#10.1    Using these standards effectively">10.1&nbsp;&nbsp;&nbsp;
Using these standards effectively</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#10.2    Other factors that lead to writing successful code">10.2&nbsp;&nbsp;&nbsp; Other factors
that lead to writing successful code</a></font>
<p><b><font face="Arial" size="2">11&nbsp;&nbsp;&nbsp; </font><A HREF="#Summary"><font face="Arial" size="2">Summary<br>
</font></a>&nbsp;&nbsp;&nbsp;<font face="Arial" size="2"><b>&nbsp;&nbsp;&nbsp;&nbsp;
</b></font></b><font face="Arial" size="2">11.1&nbsp;&nbsp;&nbsp; </font><A HREF="#Java Naming Conventions"><font face="Arial" size="2">Java naming conventions<br>
</font></a>
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;
11.2&nbsp;&nbsp;&nbsp; </font><A HREF="#Java Documentation Conventions"><font face="Arial" size="2">Java documentation conventions<br>
</font></a> 
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
11.2.1&nbsp;&nbsp;&nbsp; </font><A HREF="#Java Comment Types"><font face="Arial" size="2">Java comment types<br>
</font></a>
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
11.2.2&nbsp;&nbsp;&nbsp; </font><A HREF="#What To Document"><font face="Arial" size="2">What to document<br>
</font></a>
&nbsp;&nbsp;&nbsp;<font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp;
11.3&nbsp;&nbsp;&nbsp;</font> <A HREF="#Java Coding Conventions (General)"><font face="Arial" size="2">Java coding conventions (general)</font></a>
<p><b><font face="Arial" size="2">12&nbsp;&nbsp;&nbsp; </font><A HREF="#References"><font face="Arial" size="2">References</font></a></b>
<p><b><font face="Arial" size="2">13&nbsp;&nbsp;&nbsp; </font><A HREF="#Glossary"><font face="Arial" size="2">Glossary</font></a></b>
<p>
	<HR ALIGN=LEFT>
<H1><font face="Arial" size="4"><a name="1    Introduction">1&nbsp;&nbsp;&nbsp; Introduction</a></font><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H1> 
<blockquote>
	<P>
        This document describes a collection of standards, conventions, and guidelines for writing solid Java code. They are based on sound, proven software engineering principles that lead to code that is easy to understand, to maintain, and to enhance. Furthermore, by following these coding standards your productivity as a Java developer should increase remarkably. Experience shows that by taking the time to write high-quality code right from the start, you will have a much easier time modifying it during the development process. Finally, following a common set of coding standards leads to greater consistency, making teams of developers significantly more productive.
	</P>
</blockquote>
	  <H2><font face="Arial" size="3"><a name="1.1    The First and Last Guideline">1.1&nbsp;&nbsp;&nbsp;
      The first and last guideline</a>&nbsp;</font> <A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H2> 
	<BLOCKQUOTE>
		<P>
			<b>Use common sense.</b> When you cannot find a rule or guideline, when the rule obviously does not apply, when everything else fails: use common sense, and check the fundamental principles. This rule overrides all of the others. Common sense is <I>required</I>.
		</P>
	</BLOCKQUOTE>
	<HR ALIGN=LEFT>
      <H1><font face="Arial" size="4">2&nbsp;&nbsp;&nbsp; <A NAME="Coding Standards">Coding Standards</a> </font><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H1> 
	<BLOCKQUOTE>
		<P>
			Coding standards for Java are important because they lead to greater consistency within your code and the code of your teammates. Greater consistency leads to code that is easier to understand, which means it is easier to develop and to maintain. This reduces the overall cost of the applications that you create.
		</P>
		<P>
			You have to remember that your Java code will exist for a long time; long after you have moved on to other projects. An important goal during development is to ensure that you can transition your work to another
            developer, or to another team of developers so they can continue to maintain and enhance your work without having to invest an unreasonable effort to understand your code. Code that is difficult to understand runs the risk of being scrapped and rewritten.</P>
		
	</BLOCKQUOTE>
		<h2><font face="ARIAL" size="3"><b>2.1&nbsp;&nbsp;&nbsp; <A NAME="Naming conventions">Naming conventions</a></b></font><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></h2> 
	<BLOCKQUOTE>
		<P>
			We will be discussing naming conventions throughout the standards, so let's set the stage with a few basics: 
			
        <OL>
          <LI> <B> Use full English descriptors that accurately describe the variable, 
            field, and class</b>; for example, use names like <B>firstName</B>, 
            <B>grandTotal</B>, or <B>CorporateCustomer</B>. Although names like 
            <B>x1</B>, <B>y1</B>, or <B>fn</B> are easy to type because they're 
            short, they do not provide any indication of what they represent and 
            result in code that is difficult to understand, maintain, and enhance.<br>
          </LI>
          <LI> <B> Use terminology applicable to the domain.</b> If your users 
            refer to their clients as customers, then use the term <B>Customer</B> 
            for the class, not <B>Client</B>. Many developers make the mistake 
            of creating generic terms for concepts when perfectly good terms already 
            exist in the industry or domain.<br>
          </LI>
          <LI> <B> Use mixed case to make names readable.</b> Use lowercase letters 
            in general, but capitalize the first letter of class names and interface 
            names, as well as the first letter of any non-initial word. [<A HREF="#KAN97">KAN97</a>]<br>
          </LI>
          <LI> <B> Use abbreviations sparingly, but if you do so then use them 
            intelligently.</b> This means you should maintain a list of standard 
            short forms (abbreviations), you should choose them wisely, and you 
            should use them consistently. For example, if you want to use a short 
            form for the word &quot;number&quot;, then choose one of <B>nbr</B>, 
            <B>no</B>, or <B>num</B>, document which one you chose (it does not 
            really matter which one), and use only that one.<br>
          </LI>
          <LI> <B> Avoid long names (&lt; 15 characters is a good idea). </b>Although 
            the class name <B>PhysicalOrVirtualProductOrService</B> might seem 
            to be a good class name at the time, this name is simply too long 
            and you should consider renaming it to something shorter, perhaps 
            something like <B>Offering</B>.<br>
          </LI>
          <LI> <B> Avoid names that are similar or differ only in case. </b>For 
            example, the variable names <B>persistentObject</B> and <B>persistentObjects</B> 
            should not be used together, nor should <B>anSqlDatabase</B> and <B>anSQLDatabase</B>.<br>
          </LI>
          
    <LI> <B> Avoid leading or trailing underscores.</b> Names with leading or 
      trailing underscores are usually reserved for system purposes and should 
      not be used for any user-created names. More importantly, underscores are 
      annoying and difficult to type so try to avoid their use whenever possible.</LI>
        </OL>
</BLOCKQUOTE>
	<h2><font face="ARIAL" size="3"><b>2.2&nbsp;&nbsp;&nbsp; <A NAME="Documentation conventions">Documentation conventions</a></b></font><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></h2> 
<BLOCKQUOTE>
	<P>
		We will also be discussing documentation conventions, so let's discuss some of the basics first: 
		<OL>
		<LI> 
		<B>
			Comments should add to the clarity of your code. </b>The reason you document your code is to make it more understandable to you, your coworkers, and to any other developer who comes after you.<br>
	</LI>
<LI> 
<B>
	If your program is not worth documenting, it is probably not worth running.</b> [<A HREF="#NAG95">NAG95</a>]<br>
</LI>
<LI> 
<B>
Avoid decoration; that is, do not use banner-like comments.</b> In the 1960s and 1970s, COBOL programmers got into the habit of drawing boxes, typically with asterisks, around their internal comments. Sure, it gave them an outlet for their artistic urges, but frankly it was a major waste of time that added little value to the end product. You want to write clean code, not pretty code. Furthermore, because many of the fonts used to display and print your code are proportional, and many are not, you can't line up your boxes properly anyway.<br>
</LI>
<LI> 
<B>
Keep comments simple.</b> Some of the best comments are simple, point-form notes. You do not have to write a
book; you just have to provide enough information so that others can understand your code.<br>
</LI>
<LI> 
<B>
Write the documentation before you write the code.</b> The best way to document code is to write the comments before you write the code. This gives you an opportunity to think about how the code will work before you write it and will ensure that the documentation gets written. Alternatively, you should at least document your code as you write it. Because documentation makes your code easier to understand, you are able to take advantage of this fact while you are developing it. If you are going to invest the time writing documentation, you should at least get something out of
it. [<A HREF="#AMB98">AMB98</a>]<br>
</LI>
<LI> 
<B>
Document why something is being done, not just what.</b> For example, the code in Example 1 below shows that a 5% discount is being given on orders of $1,000 dollars or more. Why is this being done? Is there a business rule that says that large orders get a discount? Is there a limited-time special on large orders or is it a permanent program? Was the original programmer just being generous? You do not know unless it is documented somewhere, either in the source code itself or in an external document.</LI>

</OL>
<BLOCKQUOTE>
    <P STYLE="MARGIN-LEFT: 0px">
        <B>Example 1:</B>
	</P>
</BLOCKQUOTE>
	<P CLASS=EXAMPLE>
		<FONT FACE=TAHOMA SIZE=1><B>if ( grandTotal &gt;= 1000.00)</B></FONT>
	</P>
	<P CLASS=EXAMPLE>
		<FONT FACE=TAHOMA SIZE=1><B>{</B></FONT>
	</P>
	<BLOCKQUOTE>
		<P CLASS=EXAMPLE>
			<FONT FACE=TAHOMA SIZE=1><B>grandTotal = grandTotal * 0.95;</B></FONT>
		</P>
	</BLOCKQUOTE>
	<P CLASS=EXAMPLE>
		<FONT FACE=TAHOMA SIZE=1><B>}</B></FONT>
	</P>
</BLOCKQUOTE>
	<h4>2.2.1&nbsp;&nbsp;&nbsp; <A NAME="Types of Java Comments">Types of Java
    comments</a><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></h4> 
<BLOCKQUOTE>
<BLOCKQUOTE>
	<P>
		Java has three styles of comments:&nbsp;
	</P>
    <ul>
      <li>
        documentation comments that start with /** and end with */
      </li>
      <li>
		C-style comments that start with /* and end with */
      </li>
      <li>
		single-line comments that start with // and go until the end of the source-code
        line
      </li>
    </ul>
	<P>
        The following chart is a summary of a <i>suggested</i> use for each type of comment, as well as several examples.
	</P>
	<DIV ALIGN=CENTER>
		<CENTER>
			<TABLE BORDER=1 CELLPADDING=7 CELLSPACING=1 WIDTH="85%">
				<TBODY>
					<TR>
						<TH BGCOLOR="#ffffff" VALIGN=TOP WIDTH="21%" scope="col">
							<B><font face="Arial" size="1">Comment Type</font></B>
						</TH>
						<TH BGCOLOR="#ffffff" VALIGN=TOP WIDTH="40%" scope="col">
							<B><font face="Arial" size="1">Usage</font></B>
						</TH>
						<TH BGCOLOR="#ffffff" VALIGN=TOP WIDTH="40%" scope="col">
							<B><font face="Arial" size="1">Example</font></B>
						</TH>
					</TR>
					<TR>
						<TD VALIGN=TOP WIDTH="21%">
                            <font size="2"><b>Documentation</b></font>
						</TD>
						<TD VALIGN=TOP WIDTH="40%">
                            <font size="2">Use documentation comments immediately before declarations of interfaces, classes, member functions, and fields to document them. Documentation comments are processed by <I>javadoc</I>, see below, to create external documentation for a class.</font>
						</TD>
						<TD VALIGN=TOP WIDTH="40%">
                            <font size="2">/**<br>
                            Customer: A customer is any person or organization that we sell services and products to.<br>
                            @author S.W. Ambler<br>
                            */</font>
			</TD>
		</TR>
		<TR>
			<TD VALIGN=TOP WIDTH="21%">
				<b><font size="2"><i>C</i> style</font></b>
			</TD>
			<TD VALIGN=TOP WIDTH="40%">
                <font size="2">Use C-style comments to document out lines of code that are no longer applicable, but that you want to keep just in case your users change their minds, or because you want to temporarily turn it off while debugging.</font>
			</TD>
			<TD VALIGN=TOP WIDTH="40%">
                <font size="2">/*<br>
                This code was commented out by B. Gustafsson on June 4, 1999 because it was replaced by the preceding code. Delete it after two years if it is still not applicable.<br>
                . . . (the source code )<br>
                */</font>
</TD>
</TR>
<TR>
	<TD VALIGN=TOP WIDTH="21%">
		<b><font size="2">Single line</font></b>
	</TD>
	<TD VALIGN=TOP WIDTH="40%">
        <font size="2">Use single line comments internally within member functions to document business logic, sections of code, and declarations of temporary variables.</font>
	</TD>
	<TD VALIGN=TOP WIDTH="40%">
        <font size="2">// Apply a 5% discount to all<br>
			// invoices over $1000 due to<br>
        // generosity campaign started in<br>
        // Feb. of 1995.</font>
</TD>
</TR>
</TABLE>
</CENTER>
</DIV>
<FONT SIZE=3> 
<P>
	The important thing is that your organization should set a standard as to how C-style comments and single-line comments are to be used, and then to follow that standard consistently. Use one type to document business logic and use the other to document out old code. Use single-line comments for business logic because you can put the documentation on the same line as the code (this is called inlining). Use C-style comments for documenting out old code because that allows you to comment out several lines at once. Because C-style looks very similar to documentation comments, to avoid
    confusion don't use them elsewhere.
</P>
</FONT> 
<P>
	<B>Beware Endline Comments</B>-[<A HREF="#MCO93">MCO93</a>] strongly argues against the use of inline comments, also known as endline comments or end of line comments.
    McConnell points out that the comments have to be aligned to the right of the code so they don't interfere with the visual structure of the code. As a result, they tend to be hard to
    format and "if you use many of them, it takes time to align them. Such time is not spent learning more about the code; it is dedicated solely to the tedious task of pressing the spacebar or the tab key." He also points out that endline comments are also hard to maintain because when the code on the line grows, it bumps the endline comment
    out and if you are aligning them, you have to do the same for the rest of them.
</P>
</BLOCKQUOTE>
</BLOCKQUOTE>
<H4>2.2.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <A NAME="A Quick Overview of javadoc">A
quick overview of <i>javadoc</i></a>  <BIG><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></BIG></H4> 
<BLOCKQUOTE>
<BLOCKQUOTE>
	<P>
		Included in Sun's Java Development Kit (JDK) is a program called <I>javadoc</I> that processes Java code files and produces external documentation, in the form of HTML files, for your Java programs.
        <i> Javadoc</i> supports a limited number of tags; reserved words that mark the beginning of a documentation section. Please refer to the JDK <I>javadoc</I> documentation for further details.
	</P>
	 
	<DIV ALIGN=CENTER>
		<CENTER>
			<TABLE BORDER=1 CELLPADDING=7 CELLSPACING=1 WIDTH="85%">
				<TR>
					<th BGCOLOR="#ffffff" VALIGN=TOP scope="col" WIDTH="32%">
						<B><font face="Arial" size="1">Tag</font></B>
					</th>
					<th BGCOLOR="#ffffff" VALIGN=TOP scope="col" WIDTH="19%">
						<B><font face="Arial" size="1">Used for</font></B>
					</th>
					<th BGCOLOR="#ffffff" VALIGN=TOP scope="col" WIDTH="49%">
						<B><font face="Arial" size="1">Purpose</font></B>
					</th>
				</TR>
				<TR>
					<TD VALIGN=TOP WIDTH="32%">
                        <font size="2">@author name</font>
					</TD>
					<TD VALIGN=TOP WIDTH="19%">
                        <font size="2">Classes,</font> <font size="2">Interfaces</font>
				</TD>
				<TD VALIGN=TOP WIDTH="49%">
                    <font size="2">Indicates the author(s) of a given piece of code. One tag per author should be used.</font>
				</TD>
			</TR>
			<TR>
				<TD VALIGN=TOP WIDTH="32%">
                    <font size="2">@deprecated</font>
				</TD>
				<TD VALIGN=TOP WIDTH="19%">
                    <font size="2">Classes,</font> <font size="2">Member Functions</font>
			</TD>
			<TD VALIGN=TOP WIDTH="49%">
                <font size="2">Indicates that the API for the class has been deprecated and, therefore, should not be used any more.</font>
			</TD>
		</TR>
		<TR>
			<TD VALIGN=TOP WIDTH="32%">
                <font size="2">@exception name description</font>
			</TD>
			<TD VALIGN=TOP WIDTH="19%">
                <font size="2">Member Functions</font>
			</TD>
			<TD VALIGN=TOP WIDTH="49%">
                <font size="2">Describes the exceptions that a member function throws. You should use one tag per exception and give the full class name for the exception.</font>
			</TD>
		</TR>
		<TR>
			<TD VALIGN=TOP WIDTH="32%">
                <font size="2">@param name description</font>
			</TD>
			<TD VALIGN=TOP WIDTH="19%">
                <font size="2">Member Functions</font>
			</TD>
			<TD VALIGN=TOP WIDTH="49%">
                <font size="2">Used to describe a parameter passed to a member function, including its
                type or class and its usage. Use one tag per parameter.</font>
			</TD>
		</TR>
		<TR>
			<TD VALIGN=TOP WIDTH="32%">
                <font size="2">@return description</font>
			</TD>
			<TD VALIGN=TOP WIDTH="19%">
                <font size="2">Member Functions</font>
			</TD>
			<TD VALIGN=TOP WIDTH="49%">
                <font size="2">Describes the return value, if any, of a member function. You should indicate the
                type or class and the potential use(s) of the return value.</font>
			</TD>
		</TR>
		<TR>
			<TD VALIGN=TOP WIDTH="32%">
                <font size="2">@since</font>
			</TD>
			<TD VALIGN=TOP WIDTH="19%">
                <font size="2">Classes, Member Functions</font>
			</TD>
			<TD VALIGN=TOP WIDTH="49%">
                <font size="2">Indicates how long the item has existed; that is,
                since JDK 1.1.</font>
			</TD>
		</TR>
		<TR>
			<TD VALIGN=TOP WIDTH="32%">
                <font size="2">@see ClassName</font>
			</TD>
			<TD VALIGN=TOP WIDTH="19%">
                <font size="2">Classes, Interfaces, Member Functions, Fields</font>
			</TD>
			<TD VALIGN=TOP WIDTH="49%">
                <font size="2">Generates a hypertext link in the documentation to the specified class. You can, and probably should, use a fully qualified class name.</font>
			</TD>
		</TR>
		<TR>
			<TD VALIGN=TOP WIDTH="32%">
                <font size="2">@see ClassName#member functionName</font>
			</TD>
			<TD VALIGN=TOP WIDTH="19%">
                <font size="2">Classes, Interfaces, Member Functions, Fields</font>
			</TD>
			<TD VALIGN=TOP WIDTH="49%">
                <font size="2">Generates a hypertext link in the documentation to the specified member function. You can, and probably should, use a fully qualified class name.</font>
			</TD>
		</TR>
		<TR>
			<TD VALIGN=TOP WIDTH="32%">
                <font size="2">@version text</font>
			</TD>
			<TD VALIGN=TOP WIDTH="19%">
                <font size="2">Classes, Interfaces</font>
			</TD>
			<TD VALIGN=TOP WIDTH="49%">
                <font size="2">Indicates the version information for a given piece of code.</font>
			</TD>
		</TR>
	</TABLE>
</CENTER>
</DIV>
<FONT SIZE=3> 
<P>
	The way that you document your code has a huge impact, both on your own productivity and on the productivity of everyone else who later maintains and enhances it. By documenting your code early in the development process, you become more productive because it forces you to think through your logic before you commit it to code. Furthermore, when you revisit code you wrote days or weeks earlier, you can easily determine what you were thinking when you wrote
    it because it's already documented for you.</P>

</font></BLOCKQUOTE>
</BLOCKQUOTE><FONT SIZE=3>
	<HR ALIGN=LEFT>
</FONT>

<H1><font face="ARIAL" size="4"><b>3&nbsp;&nbsp;&nbsp; <A NAME="Standards For Member Functions">Standards
for Member Functions</a></b></font><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H1> 
<blockquote>
<P>
	Never forget that the code you write today may still be in use many years from now, and will likely be maintained and enhanced by somebody other than you. You must strive to make your code as "clean" and understandable as possible, because these factors make it easier to maintain and to enhance.
</P>
</blockquote>
<H2><FONT FACE=ARIAL size="3">
<B>3.1&nbsp;&nbsp;&nbsp; <A NAME="Naming Member Functions">Naming member
functions</a></b></font><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H2> 
<blockquote>
<P>
	Member functions should be named using a full English description, using mixed case with the first letter of any non-initial
    word capitalized. It is also common practice for the first word of a member function name to be a strong, active verb.
</P>
<B> 
<P>
    Examples:
</P>
</B> 
  </blockquote>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>openAccount()</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>printMailingLabel()</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>save()</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>delete()</B></FONT>
</P>
<blockquote>
<FONT SIZE=3> 
<P>
	This convention results in member functions whose purpose can often be determined just by looking at
    their names. Although this convention results in a little extra typing by the
    developer because it often results in longer names, this is more than made up for by the increased understandability of your code.</P>
  </font></blockquote>


<h3> <font face="ARIAL" size="3">3.1.1&nbsp;&nbsp;&nbsp; <A NAME="Naming Accessor Member Functions">Naming
accessor member functions</a></font><SMALL><SMALL>
</SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></h3><BLOCKQUOTE> 
<SMALL>
	<P>
		We will discuss accessors, member functions that get and set the values of fields
        (fields or properties) in greater detail in a next chapter. The naming conventions for accessors, however, are summarized below.
	</P>
</small>
<h4><b><font face="ARIAL" size="2">3.1.1.1&nbsp;&nbsp;&nbsp; <A NAME="Getters">Getters</a>&nbsp;</font></b>
<A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></h4> 
<SMALL>

<P>
	Getters are member functions that return the value of a field. You should prefix the word "get" to the name of the field, unless it is a boolean field and then you prefix "is" to the name of the field instead of "get".
</P>

	<B> 
	<P>
		<BIG>Examples:</BIG></P></B>

</small> 
</BLOCKQUOTE>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>getFirstName()</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>getAccountNumber()</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>isPersistent()</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>isAtEnd()</B></FONT>
</P>
<BLOCKQUOTE>

<P>
    
	By following this naming convention, you make it obvious that a member function returns a field of an object, and for boolean getters you make it obvious that it returns true or false. Another advantage of this standard is that it follows the naming conventions used by the
    Beans Development Kit (BDK) for getter member functions. [<A HREF="#DES97">DES97</a>] The main disadvantage is that "get" is
    superfluous and requires extra typing.</P>
</BLOCKQUOTE>
<SMALL>
<BLOCKQUOTE>
	<p> <b>Alternative naming convention for Getters:
    has and can</b></p> 
</BLOCKQUOTE>
</SMALL><BLOCKQUOTE><SMALL>
	<P>
		A viable alternative, based on proper English conventions, is to use the prefix "has" or "can" instead of "is" for boolean getters. For example, getter names such as <B>hasDependents()</B> and <B>canPrint()</B> make a lot of sense when you are reading the code. The problem with this approach is that the BDK will not pick up on this naming strategy (yet). You could rename these member functions <B>isBurdenedWithDependents()</B> and <B>isPrintable()</B>.
	</P>
	 
</small>
<h4> <B><font face="ARIAL" size="2">3.1.1.2&nbsp;&nbsp;&nbsp; <A NAME="Setters">Setters</a></font></b><small><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></h4> 
<SMALL>
	<P>
		Setters, also known as mutators, are member functions that modify the values of a field. You should prefix the word "set" to the name of the field, regardless of the field type.
	</P>
	<B> 
	<P>
		<BIG>Examples:</BIG></P></B>

</small> 
	 
</BLOCKQUOTE>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>setFirstName(String aName)</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>setAccountNumber(int anAccountNumber)</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>setReasonableGoals(Vector newGoals)</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>setPersistent(boolean isPersistent)</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>setAtEnd(boolean isAtEnd)</B></FONT>
</P>
<BLOCKQUOTE>
  
    <P>By following this naming convention, you make it obvious that a member function sets the value of a field of an object. Another advantage of this standard is that it follows the naming conventions used by the
    BDK for setter member functions. [<A HREF="#DES97">DES97</a>] The main disadvantage is that "set" is
    superfluous and requires extra typing.
	</P>

	 
</BLOCKQUOTE>
<H2> <B><font face="ARIAL" size="3">3.2&nbsp;&nbsp;&nbsp; <A NAME="Constructors">Naming
constructors</a></font></b><small><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></H2><small> 
<BLOCKQUOTE>
<P>
	Constructors are member functions that perform any necessary initialization when an object is first created. Constructors are always given the same name as their class. For example, a constructor for the class <B>Customer</B> would be <B>Customer()</B>. Note that the same case is used.
</P>
</BLOCKQUOTE>
<BLOCKQUOTE>
<B> 
<P>
	<BIG>Examples:</BIG></P></B>

</BLOCKQUOTE>
</small> 
	<P CLASS=EXAMPLE>
		<FONT FACE=TAHOMA SIZE=1><B>Customer()</B></FONT>
	</P>
	<P CLASS=EXAMPLE>
		<FONT FACE=TAHOMA SIZE=1><B>SavingsAccount()</B></FONT>
	</P>
	<P CLASS=EXAMPLE>
		<FONT FACE=TAHOMA SIZE=1><B>PersistenceBroker()</B></FONT>
	</P>
<SMALL> 
<BLOCKQUOTE>
	 
	<P>
		This naming convention is set by Sun Microsystems and must be strictly adhered to.</P>

</BLOCKQUOTE>
</SMALL>
<H2><FONT FACE=ARIAL size="3"> <B>3.3&nbsp;&nbsp;&nbsp; <A NAME="Member Function Visibility">Member
function visibility</a></b></font>
<SMALL> 
<SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></H2><BLOCKQUOTE> 

<P>
	For a good design where you minimize the coupling between classes, the general rule of thumb is to be as restrictive as possible when setting the visibility of a member function. If a member function does not have to be public, then make it protected, and if it does not have to be protected, then make it private.
</P>
 

 
<DIV ALIGN=CENTER>
	<CENTER>
		
      <TABLE BORDER=1 CELLPADDING=7 CELLSPACING=1 WIDTH="85%">
        <TR> 
          <TH BGCOLOR="#ffffff" VALIGN=TOP WIDTH="14%" scope="col"> <B><font face="Arial" size="1">Visibility</font></B> 
          </TH>
          <TH BGCOLOR="#ffffff" VALIGN=TOP WIDTH="43%" scope="col"> <B><font face="Arial" size="1">Description</font></B> 
          </TH>
          <TH BGCOLOR="#ffffff" VALIGN=TOP WIDTH="43%" scope="col"> <B><font face="Arial" size="1">Proper 
            Usage</font></B> </TH>
        </TR>
        <TR> 
          <TD VALIGN=TOP WIDTH="14%"> <b><font size="2">public</font></b> </TD>
          <TD VALIGN=TOP WIDTH="43%"> <font size="2">A public member function 
            can be invoked by any other member function in any other object or 
            class.</font> </TD>
          <TD VALIGN=TOP WIDTH="43%"> <font size="2">When the member function 
            must be accessible by objects and classes outside of the class hierarchy 
            in which the member function is defined.</font> </TD>
        </TR>
        <TR> 
          <TD VALIGN=TOP WIDTH="14%"> <b><font size="2">protected</font></b> </TD>
          <TD VALIGN=TOP WIDTH="43%"> <font size="2">A protected member function 
            can be invoked by any member function in the class in which it is 
            defined, any subclasses of that class, or any classes in the same 
            package. </font></TD>
          <TD VALIGN=TOP WIDTH="43%"> <font size="2">When the member function 
            provides behavior that is needed internally within the class hierarchy 
            or package, but not externally.</font> </TD>
        </TR>
        <tr> 
          <td valign=TOP width="14%"> <b><font size="2">private</font></b> </td>
          <td valign=TOP width="43%"> <font size="2">A private member function 
            can only be invoked by other member functions in the class in which 
            it is defined, but not in the subclasses.</font> </td>
          <td valign=TOP width="43%"> <font size="2">When the member function 
            provides behavior that is specific to the class. Private member functions 
            are often the result of refactoring, also known as reorganizing, the 
            behavior of other member functions within the class to encapsulate 
            one specific behavior.</font> </td>
        </tr>
        <TR> 
          <TD VALIGN=TOP WIDTH="14%"> <b><font size="2">default</font></b> </TD>
          <TD VALIGN=TOP WIDTH="43%"> <font size="2">By default (no visibility 
            specified), a function can only be invoked by other member functions 
            in the class in which it is defined, or any classes in the same package.</font></TD>
          <TD VALIGN=TOP WIDTH="43%"> <font size="2">When the member function 
            provides behaviour that is needed by classes within the same package, 
            but not externally, and not by subclasses.</font></TD>
        </TR>
      </TABLE>
	</CENTER>
</DIV>
</BLOCKQUOTE>
<H2><font face="ARIAL" size="3"><b>3.4&nbsp;&nbsp;&nbsp; <A NAME="Documenting Member Functions">Documenting
member functions</a></b></font><small><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></H2><small> 
<BLOCKQUOTE>
<FONT SIZE=3> 
<P>
	The manner in which you document a member function will often be the deciding factor as to whether or not it is
    understandable and, therefore, maintainable and extensible.</P></FONT>

</BLOCKQUOTE>
</small>
<H3> <FONT FACE=ARIAL size="3"><a name="3.4.1    The member function header">3.4.1&nbsp;&nbsp;&nbsp;
The member function
header</a></font><small><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a>
</small>
</H3> 
<BLOCKQUOTE>
<SMALL>
	<P>
		Every Java member function should include some sort of header, called member function documentation, at the top of the source code that documents all of the information that is critical to understanding it. This information includes, but is not limited to, the following:</small> 
		<OL>
		<LI> 
		<B>
			What and why the member function does what it does</b>. By documenting what a member function does, you make it easier for others to determine if they can reuse your code. Documenting why it does something makes it easier for others to put your code into context. You also make it easier for others to determine whether or not a new change should actually be made to a piece of code (perhaps the reason for the new change conflicts with the reason why the code was written in the first place).<br>
	</LI>
<LI> 
<B>
	What member function must be passed as parameters</b>. You also need to indicate what parameters, if any, must be passed to a member function and how they will be used. This information is needed so that other programmers know what information to pass to a member function. <I>javadoc</I> <I>@param</I> tag, discussed in
section <a href="#A Quick Overview of javadoc">2.2.2, <i>A quick overview of javadoc</i></a>, is used for this.<br>
</LI>
<LI> 
<B>
What a member function returns</b>. You need to document what, if anything, a member function returns so that other programmers can use the return
value or object appropriately. The <I>javadoc</I> <I>@return</I> tag, discussed in
section <a href="#A Quick Overview of javadoc">2.2.2, <i>A quick overview of javadoc</i></a>, is used for this.<br>
</LI>
<LI> 
<B>
Known bugs.</b> Any outstanding problems with a member function should be documented so that other developers understand the
weaknesses and difficulties with the member function. If a given bug is applicable to more than one member function within a class, then it should be documented for the class instead.<br>
</LI>
<LI> 
<B>
Any exceptions that a member function throws.</b> You should document any and all exceptions that a member function throws so that other programmers know what their code will need to catch. The <I>javadoc</I> <I>@exception</I> tag, discussed in
section <a href="#A Quick Overview of javadoc">2.2.2, <i>A quick overview of javadoc</i></a>, is used for this.<br>
</LI>
<LI> 
<B>
Visibility decisions.</b> If you feel that your choice of visibility for a member function will be questioned by other
developers-perhaps you have made a member function public even though no other objects invoke the member function
yet-then you should document your decision. This will help to make your thinking clear to other developers so that they do not waste time worrying about why you did something questionable.<br>
</LI>
<LI> 
<B>
How a member function changes the object</b>. If a member function changes an object, for example the <B>withdraw()</B> member function of a bank account modifies the account balance, then this needs to be indicated. This information is needed so that other Java programmers know exactly how a member function invocation will affect the target object.<br>
</LI>
<LI> 
<B>
Avoid the use of headers containing information</b> such as author, phone numbers, dates of creation and modification, and location of unit (or
file name), because this information rapidly becomes obsolete. Place ownership copyright notices at the end of the unit. For instance, readers do not want to have to scroll through two or three pages of text that is not useful
to the understanding of the program, nor do they want to scroll through text that does not carry any program information at all, such as a copyright notice. Avoid the use of vertical bars or closed frames or boxes, which just add visual noise and are difficult to keep consistent. Use a configuration management tool to keep unit history.<br>
</LI>
<LI> 
<B>
Examples of how to invoke the member function if appropriate</b>. One of the easiest ways to determine how a piece of code works
is to look at an example. Consider including an example or two about how to invoke a member function.<br>
</LI>
 <LI> 

<B>
    Applicable preconditions and postconditions</b>. A precondition is a constraint under which a member function will function properly, and a
postcondition is a property or assertion that will be true after a member function is finished running. [<A HREF="#MEY88">MEY88</a>] In many ways
preconditions and postconditions describe the assumptions that you have made when writing a member function [<A HREF="#AMB98">AMB98</a>], defining exactly the boundaries of how a member function is used.<br>
 <LI> 

<B>
    All concurrency issues.</b> Concurrency is a new and complex concept for many developers and, at best, it is an old and complex topic for experienced concurrent programmers. The end result is that if you use the concurrent programming features of Java, then you need to document it thoroughly. [<A HREF="#LEA97">LEA97</a>] suggests that when a class includes both synchronized and unsynchronized member functions, you must document the execution context that a member function relies on, especially when it requires unrestricted access so that other developers can use your member functions safely. When a setter, a member function that updates a field, of a class that implements the <B>Runnable</B> interface is not synchronized, then you should document your reason(s) why. Finally, if you override or overload a member function and change its synchronization, you should also document why.<br>

</LI>
<SMALL> 
<li>
	<b>You should document something only when it adds to the clarity of your code</b>. You would not document all of the factors described above for each and every member function because not all factors are applicable to every member function. You would, however, document several of them for each member function that you write.
</li>
</small></OL>
 

</BLOCKQUOTE>
<H3><FONT FACE=ARIAL><small><a name="3.4.2    Internal documentation">3.4.2&nbsp;&nbsp;&nbsp; Internal documentation</a></small></FONT><small><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></H3><small> 
<BLOCKQUOTE>
<BLOCKQUOTE>
	<P>
		In addition to the member function documentation, you also need to include comments within your member functions to describe your work. The goal is to make your member function easier to understand, maintain, and enhance.
	</P>
	<P>
		There are two types of comments that you should use to document the internals of your code C-style comments (&nbsp;/*&nbsp;and&nbsp;*/&nbsp;) and single-line comments (&nbsp;//&nbsp;). As
        previously discussed, you should seriously consider choosing one style of comments for documenting the business logic of your code and one for commenting out unneeded code. It is suggested that you use single-line comments for your business logic, because you can use this style of comments both for full comment lines and for inline comments that follow at the end of a line of code. Use C-style comments to document out lines of unneeded code because it makes it easier to take out several lines with only one comment. Furthermore, because C-style comments look so much like documentation comments, their use can be confusing,
    which takes away from the understandability of your code. Therefore, use them sparingly.
	</P>
	<P>
		Internally, you should always document the following: 
	<OL>
	<LI> 
	<B>
		Control structures.</b> Describe each control structure, such as comparison statements and loops. You should not have to read all the code in a control structure to determine what it
    does; instead you should just have to look at a one or two line comment immediately preceding it.<br>
</LI>
<LI> 
<B>
Why, as well as what, the code does.</b> You can always look at a piece of code and figure out what it does, but for code that is not obvious, you can rarely determine why it
was done that way. For example, you can look at a line of code and easily determine that a 5% discount is being applied to the total of an order. That is easy. What is not easy is figuring out WHY that discount is being applied. Obviously there is some sort of business rule that says to apply the discount, so that business rule should at least be referred to in your code so that other developers can understand why your code does what it does.<br>
</LI>
<LI> 
<B>
Local variables.</b> Although we will discuss this in greater detail in <a href="#5    Standards for Local Variables"> Chapter
5</a>, each local variable defined in a member function should be declared on its own line of code and should usually have an inline comment describing its use.<br>
</LI>
<LI> 
<B>
Difficult or complex code.</b> If you find that you either can't rewrite it, or do not have the time, then you must thoroughly
<small> document </small> any complex code in a member function. A general rule of thumb is that if your code is not obvious, then you need to document it.<br>
</LI>
<LI> 
<B>
The processing order.</b> If there are statements in your code that must be executed in a defined order, then you should ensure that this fact gets documented [<A HREF="#AMB98">AMB98</a>]. There's nothing worse than making a simple modification to a piece of code only to find that it no longer works, then spending hours looking for the problem only to find that you have gotten things out of order.<br>
    </LI>

      <li>
	<B>Document your closing braces. </B>Every so often, you will find that you have control structures within control structures within control structures. Although you should avoid writing code like this, sometimes you find that it is better to write it this way. The problem is that it becomes confusing
    as to which ending brace the <B>}</B>  character belongs to, which control structure. The good news is that some code editors support a feature that, when you select a open brace, will automatically highlight the corresponding closing
    one; the bad news is that not every editor supports this. I have found that marking the ending braces with an inline comment, such as <B>//end if</B>, <B>//end for</B>, <B>//end switch</B>, makes your code easier to understand.
</li>

</OL>
 
</BLOCKQUOTE>
</BLOCKQUOTE>
</small>
<H2><FONT FACE=ARIAL size="3"> <B>3.5&nbsp;&nbsp;&nbsp; <A NAME="Techniques for Writing Clean Code">Techniques for
writing clean code</a></b></font><small><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></H2><small> 
<BLOCKQUOTE>
<P>
	This section covers several techniques that help separate the professional developers from the hack coders. These techniques are: 
	    <UL>
          <LI> Document your code. </LI>
          <LI> Paragraph or indent your code. </LI>
          <LI> Use whitespace. </LI>
          <LI> Follow the 30-second rule. </LI>
          <LI> Write short, single command lines.</LI>
          <LI> Specify the order of operations.</LI>
        </UL>
</BLOCKQUOTE>
</small>
<H3> <FONT FACE=ARIAL size="3"><a name="3.5.1    Document Your Code">3.5.1&nbsp;&nbsp;&nbsp; Document Your Code</a>&nbsp;</font>
<A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H3> 
<small>
<BLOCKQUOTE>
<FONT SIZE=3> 
<P>
	Remember-if your code is not worth documenting, then it is not worth
    keeping.[<A HREF="#NAG95">NAG95</a>] When you apply the documentation standards and guidelines proposed in
    this document appropriately, you can greatly enhance the quality of your code.
</P>
</FONT> 
</BLOCKQUOTE>
</small>
<H3> <FONT FACE=ARIAL><small><a name="3.5.2    Paragraph or indent your code">3.5.2&nbsp;&nbsp;&nbsp;
Paragraph or
indent your code</a>&nbsp;</small></font> <A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H3> 
<small> 
<BLOCKQUOTE>
<P>
	One way to improve the readability of a member function is to paragraph
    it or, in other words, indent your code within the scope of a code block. Any code within braces, the <B>{</B> and <B>}</B> characters, forms a block. The basic idea is that the code within a block should be uniformly indented one unit.
</P>
<P>
	The Java convention appears to be that the open brace is to be put on the line following the owner of the block and that the closing brace should be indented one level. The important thing, pointed out by [<A HREF="#LAF97">LAF97</a>], is that your organization chooses an indentation style and sticks to it. Use the same indentation style that your Java development environment uses for the code that it generates.</P>

</BLOCKQUOTE></small><h3>
	<b><FONT SIZE=3 face="Arial"><a name="3.5.3    Use whitespace in your code">3.5.3&nbsp;&nbsp;&nbsp; Use whitespace in
    your code</a>&nbsp;</FONT></b> <A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></h3>
<BLOCKQUOTE> 
<P>A few blank lines, called whitespace, added to your Java code can help make it much more readable by
  dividing it into small, easy-to-digest sections. [<A HREF="#VIS96">VIS96</a>] suggests using a single blank line to separate logical groups of code, such as control structures, with two blank lines to separate member function definitions. Without whitespace, it is very difficult to read and to understand.</P>
  
</BLOCKQUOTE>
	<H3> <FONT FACE=ARIAL size="3"><a name="3.5.4   Follow the 30-second rule">3.5.4&nbsp;&nbsp;&nbsp;
    Follow
    the 30-second rule</a>&nbsp;</font> <A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H3> 
<small><small>
<BLOCKQUOTE>
	<P>
		Other programmers should be able to look at your member function and fully understand what it does, why it does it, and how it does it in less than 30 seconds. If this is not possible, then your code is too difficult to maintain and should be improved. Thirty
        seconds; that's it. A good rule of thumb is that if a member function is more than a screen, then it's probably too long.
	</P>
	 
</BLOCKQUOTE>
</small></small>
	<H3><FONT FACE=ARIAL size="3"><a name="3.5.5    Write short, single command lines">3.5.5&nbsp;&nbsp;&nbsp; Write short,
    single command lines</a>&nbsp;</FONT> <A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H3> 
<small><small>
<BLOCKQUOTE>
	<P>
		Your code should do one thing per line. Back in the days of punch cards, it made sense to try to get as much functionality as possible on a single line of code. Whenever you attempt to do more than one thing on a single line of code, you make it harder to understand. Why do this? We want to make our code easier to understand so that it is easier to maintain and enhance. Just like a member function should do one thing and one thing only, you should only do one thing on a single line of code.
	</P>
	<P>
		Furthermore, you should write code that remains visible on the screen [<A HREF="#VIS96">VIS96</a>]. You should not have to scroll your editing window to the right to read the entire line of code, including code that uses inline comments.</P>
	
</BLOCKQUOTE>
</small></small>
	<H3> <FONT FACE=ARIAL size="3"><a name="3.5.6    Specify the order of operations">3.5.6&nbsp;&nbsp;&nbsp;
    Specify the
    order of operations</a>&nbsp;</font> <A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H3> 
<small><small>
<BLOCKQUOTE>
	<P>
		A really easy way to improve the understandability of your code is to use
        parentheses, also called "round brackets&quot;, to specify the exact order of operations in your Java code [<A HREF="#NAG95">NAG95</a>] and [<A HREF="#AMB98">AMB98</a>]. If you have to know the order of operations for a language to understand your source code, then something is seriously wrong. This is mostly an issue for logical comparisons where you AND and OR several other comparisons together. Note that if you use short, single-command lines, as
        previously suggested, then this really should not become an issue.
	</P>
</BLOCKQUOTE>
	<HR ALIGN=LEFT>
</small></small><H1><B><font face="ARIAL" size="4">4&nbsp;&nbsp;&nbsp; <A NAME="Standards For Fields">Standards
for Fields and Properties</a></font></B><small><small><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></small></H1><small><small> <FONT SIZE=3> 
<blockquote>
<P>
	The term <I>field</I>  used here refers to a field that the BDK calls a property [<A HREF="#DES97">DES97</a>]. A field is a piece of data that describes an object or class. Fields may be base data type, like a string or a float, or may be an object, such as a customer or
    a bank account.</P>
</blockquote>
</font></small></small>


<H2><FONT FACE=ARIAL size="3"> <B>4.1&nbsp;&nbsp;&nbsp; <A NAME="Naming Fields">Naming
fields</a></b></font><small><small><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></small></H2><BLOCKQUOTE><small> 
<small>
	<P>
		You should use a full English descriptor to name your fields, [<A HREF="#GOS96">GOS96</a>] and [<A HREF="#AMB98">AMB98</a>],
        thereby making it obvious what the field represents. Fields that are collections, such as arrays or vectors, should be given names that are plural to indicate that they represent multiple values.
	</P>
</small></small>
	<B> 
	<P>
        <font size="3">Examples:</font>
	</P>
</B> 

</BLOCKQUOTE><small>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>firstName</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>zipCode</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>unitPrice</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>discountRate</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>orderItems</B></FONT>  
</P>
</small><H3>
<FONT FACE=ARIAL size="3"><b>4.1.1&nbsp;&nbsp;&nbsp; <A NAME="Naming Components">Naming
components</a>  (widgets)</b></font><small><small><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></small></H3><BLOCKQUOTE>
	<P>
		For names of components (interface widgets), you should use a full English descriptor postfixed by the widget type. This makes it easy for you to identify the purpose of the component, as well as its type,
        which makes it easier to find each component in a list. Many visual programming environments provide lists of all components in an applet or application and it can be confusing when everything is named <B>button1</B>, <B>button2</B>, and so on.
	</P>

	<P>
        <b><font size="3">Examples:</font></b>
	</P>

</BLOCKQUOTE><small>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>okButton</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>customerList</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>fileMenu</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>newFileMenuItem</B></FONT>
</P>
</small>
<BLOCKQUOTE>
	<H4><FONT FACE=ARIAL size="2"> <B><a name="4.1.1.1    Alternative for naming components: Hungarian notation">4.1.1.1&nbsp;&nbsp;&nbsp; Alternative for
    naming components: Hungarian notation</a>&nbsp;</b></font> <A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H4> 
 
<P>
	The "Hungarian Notation" [<A HREF="#MCO93">MCO93</a>] is based on the principle that a field should be named using the following approach: xEeeeeeEeeeee where x indicates the component type and EeeeeEeeeee is the full English descriptor.
</P>

<B> 
<P>
    <font size="3">Examples:</font>
</P>
</B> 

</BLOCKQUOTE><small>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>pbOk</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>lbCustomer</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>mFile</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>miNewFile</B></FONT>
</P>
</small><BLOCKQUOTE><P>
			The main advantage is that this is an industry standard common for C++ code so many people already follow it.
            From the name of the variable, 

 developers can quickly judge its type and how it's used. The main disadvantages are that the prefix notation becomes </P>

<H4> <B><font face="ARIAL" size="2"><a name="4.1.1.2    Alternative for naming components: postfix-Hungarian notation">4.1.1.2&nbsp;&nbsp;&nbsp; Alternative for
naming components: postfix-Hungarian notation</a>&nbsp;</font></b> <A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H4> 
</BLOCKQUOTE>
<BLOCKQUOTE>
<P>
	Basically this is a combination of the other two alternatives
    and it results in names such as <B>okPb</B>, <B>customerLb</B>, <B>fileM</B>, and <B>newFileMi</B>. The main advantage is that the name of the component indicates the widget type and that widgets of the same type are not grouped together in an alphabetical list. The main disadvantage is that you still are not using a full English description, making the standard harder to remember because it deviates from the norm.
</P>
 
<h4>
	<B><font face="Arial" size="2"><a name="4.1.1.3    Set component name standards">4.1.1.3&nbsp;&nbsp;&nbsp; Set component name
    standards</a>&nbsp;</font></B> <A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a>
</h4>

<P>Whatever convention you choose, you'll want to create a list of "official" widget names. For example, when naming buttons, do you use <B>Button</B> or <B>PushButton</B>, <B>b</B> or <B>pb</B>? Create a list and make it available to every Java developer in your organization
</P>
</BLOCKQUOTE>

<H3> <FONT FACE=ARIAL size="3">4.1.2&nbsp;&nbsp;&nbsp; <A NAME="Naming Constants">Naming
constants</a></font><small><small><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></small></H3><small><small> 
<BLOCKQUOTE>
<P>
	In Java, constants-values that do not change-are typically implemented as <I>static final</I> fields of classes. The recognized convention is to use full English words, all in uppercase, with underscores between the words [<A HREF="#GOS96">GOS96</a>].
</P>

<B> 
<P>
   Examples:
</P>
</B> 
</BLOCKQUOTE>
<small> 
	<P CLASS=EXAMPLE>
		<FONT FACE=TAHOMA SIZE=1><B>MINIMUM_BALANCE</B></FONT>
	</P>
	<P CLASS=EXAMPLE>
		<FONT FACE=TAHOMA SIZE=1><B>MAX_VALUE</B></FONT>
	</P>
	<P CLASS=EXAMPLE>
		<FONT FACE=TAHOMA SIZE=1><B>DEFAULT_START_DATE</B></FONT>
	</P>
<SMALL> 
<BLOCKQUOTE>
	<FONT SIZE=3> 
	<P>
		The main advantage to this convention is that it helps you distinguish constants from variables. We will see later in
        this document that you can greatly increase the flexibility and maintainability of your code by not defining
        constants; instead you should define getter member functions that return the value of constants.
	</P>
</FONT> 
</BLOCKQUOTE>
</SMALL></small>
<H3> <FONT FACE=ARIAL size="3">4.1.3&nbsp;&nbsp;&nbsp; <A NAME="Naming Collections">Naming
collections</a></font><small><small><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></small></H3><BLOCKQUOTE> 

<P>
	A collection, such as an array or a vector, should be given a pluralized name representing the types of objects stored by the array. The name should be a full English descriptor, with the first letter of all non-initial words capitalized.
</P>


<B> 
<P>
   Examples:</P></B>


</BLOCKQUOTE><small>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>customers</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>orderItems</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>aliases</B></FONT>
</P>
</small>
<BLOCKQUOTE>

<small>
<SMALL> <FONT SIZE=3> 
	<P>
		The main advantage of this convention is that it helps to distinguish fields that represent multiple values (collections) from those that represent single values (non-collections).</P></FONT>

</small></small></BLOCKQUOTE>
<H2><FONT FACE=ARIAL size="3"> <B>4.2&nbsp;&nbsp;&nbsp; <A NAME="Field Visibility">Field
visibility</a></b></font><small><small><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></small></H2></small></small><BLOCKQUOTE> 

<P>
	When fields are declared <I>protected,</I> there is the possibility of member functions in subclasses to directly access them, effectively increasing the coupling within a class hierarchy. This makes your classes more difficult to maintain and to enhance, therefore, it should be avoided. Fields should never be accessed
    directly; instead accessor member functions (see below) should be used.
</P>
 

 
<DIV ALIGN=CENTER>
	<CENTER>
		<TABLE BORDER=1 CELLPADDING=7 CELLSPACING=1 WIDTH="85%">
			<TR>
				<TH BGCOLOR="#ffffff" VALIGN=TOP WIDTH="14%" scope="col">
					<B><font face="Arial" size="1">Visibility</font></B>
				</TH>
				<TH BGCOLOR="#ffffff" VALIGN=TOP WIDTH="43%" scope="col">
					<B><font face="Arial" size="1">Description</font></B>
				</TH>
				<TH BGCOLOR="#ffffff" VALIGN=TOP WIDTH="43%" scope="col">
					<B><font face="Arial" size="1">Proper Usage</font></B>
				</TH>
			</TR>
            <small>
            <small>
			<TR>
				<TD VALIGN=TOP WIDTH="14%">
                    <font size="2">public</font>
				</TD>
				<TD VALIGN=TOP WIDTH="43%">
                    <font size="2">A public field can be accessed by any other member function in any other object or class.</font>
				</TD>
				<TD VALIGN=TOP WIDTH="43%">
                    <font size="2">Do not make fields public.</font>
				</TD>
			</TR>
			<TR>
				<TD VALIGN=TOP WIDTH="14%">
                    <font size="2">protected</font>
				</TD>
				<TD VALIGN=TOP WIDTH="43%">
                    <font size="2">A protected field can be accessed by any member function in the class in which it is declared or by any member functions defined in subclasses of that class.</font>
				</TD>
				<TD VALIGN=TOP WIDTH="43%">
                    <font size="2">Do not make fields protected.</font>
				</TD>
			</TR>
			<TR>
				<TD VALIGN=TOP WIDTH="14%">
                    <font size="2">private</font>
				</TD>
				<TD VALIGN=TOP WIDTH="43%">
                    <font size="2">A private field can only be accessed by member functions in the class in which it is declared, but not in the subclasses.</font>
				</TD>
				<TD VALIGN=TOP WIDTH="43%">
                    <font size="2">All fields should be private, and should be accessed by getter and setter member functions (accessors).</font>
				</TD>
			</TR>
		</small></small></TABLE>
	</CENTER>
</DIV>
<FONT SIZE=3> 
<P>
	For fields that are not persistent (they will not be saved to permanent storage), you should mark them as either <I>static</I> or <I>transient</I> [<A HREF="#DES97">DES97</a>]. This makes them conform to the conventions of the BDK.</P></FONT>

</BLOCKQUOTE>

    
 
<H3> <a name="4.2.1    Do not &quot;hide&quot; names"><font face="ARIAL" size="3">4.2.1&nbsp;&nbsp;&nbsp; Do not &quot;hide&quot;
names</font></a><small><small><FONT FACE=ARIAL size="3">&nbsp;</font> <A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a>
 
    </small></small>
 
</H3> 
            <small>
            <small>
<BLOCKQUOTE>
 
<P>
	Name hiding refers to the practice of naming a local variable, argument, or field the same (or similar) as that of another one of greater scope. For example, if you have a field called <B>firstName</B> do not create a local variable or parameter called <B>firstName</B>, or anything close to it like <B>firstNames</B> or <B>fistName</B>. This makes your code difficult to understand and prone to bugs because other developers, or you, will misread your code while they are modifying it and
    will make difficult-to-detect errors.
</P>
</BLOCKQUOTE>

<H2><FONT FACE=ARIAL size="3"> <B>4.3&nbsp;&nbsp;&nbsp; <A NAME="Documenting a Field">Documenting a
field</a> </b></font><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H2> 
<BLOCKQUOTE>
<P>
	Every field should be documented well enough so that other developers can understand it. To be effective, you need to document: 
<OL>
	<LI> 
	<B>
		Its description.</b> You need to describe a field so that people know how to use it.<br>
</LI>
  
<LI> 
<B>All applicable invariants.</b> Invariants of a field are the conditions that are always true about it. For example, an invariant about the field <B>dayOfMonth</B> might be that its value is between 1 and 31 (obviously you could get far more complex with this invariant, restricting the value of the field based on the month and the year). By documenting the restrictions on the value of a field, you help to define important business
rules that make it easier to understand how your code works.<br>
</LI>
<LI> 
<B>
Examples.</b> For fields that have complex business rules associated with them, you should provide several example values to make them easier to understand. An example is often like a
good picture: it's worth a thousand words.<br>
</LI>
<LI> 
<B>
Concurrency issues.</b> Concurrency is a new and complex concept for many
developers; actually, at best, it is an old and complex topic for experienced concurrent programmers. The end result is that if you use the concurrent programming features of Java, then you need to document
them thoroughly.<br>
</LI>
<LI> 
<B>
Visibility decisions.</b> If you have declared a field to be anything but private, then you should document why you have done so. Field visibility
was previously discussed in section <a href="#Field Visibility"> 4.2, Field
visibility</a> and the use of accessor member functions to support encapsulation is covered
next in section <a href="#Using Accessor Member Functions"> 4.4, Using of accessor member
functions</a>. The bottom line is that you better have a really good reason for not declaring a variable as private.</LI>

</OL>
</BLOCKQUOTE>
<H2><font size="3"><FONT FACE=ARIAL> <B>4.4&nbsp;&nbsp;&nbsp; <A NAME="Using Accessor Member Functions">Using
accessor member functions</a></b></font> </font><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H2> 
<BLOCKQUOTE>
<P>
	In addition to naming conventions, the maintainability of fields is achieved by the appropriate use of <I>accessor member functions</I>-member functions that provide the functionality to either update a field or to access its value. Accessor member functions come in two flavors: <I>setters</I> (also called <I>mutators</I>) and <I>getters</I>. A setter modifies the value of a variable, whereas a getter obtains it for you.
</P>
<P>
	Although accessor member functions used to add overhead to your code, Java compilers are now optimized for their
    use so this is no longer true. Accessors help to hide the implementation details of your class. By having two control points
    at most from which a variable is accessed, one setter and one getter, you are able to increase the maintainability of your classes by minimizing the points at which changes need to be made. Optimization of Java code is discussed in
    section <a href="#Optimizing Java Code">9.3, Optimizing Java Code</a>.</P>

<P>
	<b>One of the most important standards that your organization can enforce is the use of accessors</b>. Some developers do not want to use accessor member functions because they do not want to type the few extra keystrokes required; for example, for a getter you need to type in "get" and "()" above and beyond the name of the field. The bottom line is that the increased maintainability and extensibility from using accessors more than justifies their use.
</P>
<P>
	<B>Accessors are the only place to access fields. </B>A key concept with the appropriate use of accessor member functions is that the ONLY member functions that are allowed to directly work with a field are the accessor member functions themselves. Yes, it's possible to directly access a private field within the member functions of the class in which the field is defined, but you do not want to do so because you would increase the coupling within your class.
</P>
</BLOCKQUOTE>
<h3>
    <font face="Arial" size="3"><a name="4.4.1    Why use accessors?">4.4.1&nbsp;&nbsp;&nbsp; Why use accessors?</a>&nbsp;</font><FONT FACE=ARIAL size="3">
    </font><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></h3>
            
      </small></small>
<BLOCKQUOTE><small><FONT SIZE=3><small>
<P>
    "Good program design seeks to isolate parts of a program from unnecessary, unintended, or otherwise unwanted outside influences. Access modifiers (accessors) provide an explicit and checkable means for the language to control such contacts." [<A HREF="#KAN97">KAN97</a>]</P>
<P>
	Accessor member functions improve the maintainability of your classes in the following ways: 
<OL>
<LI> 
<B>
	Updating fields</b>. You have single points of update for each field, making it easier to modify and to test. In other words your fields are encapsulated.<br>
</LI>
<LI> 
<B>
Obtaining the values of fields</b>. You have complete control over how fields are accessed and by whom.<br>
</LI>
<LI> 
<B>
Obtaining the values of constants and the names of classes</b>. By encapsulating the value of constants and of class names in getter member functions when those values/names change you only need to update the value in the getter and not every line of code where the constant/name is used.<br>
</LI>
<LI> 
<B>
Initializing fields</b>. The use of lazy initialization ensures that fields are always initialized and that they are initialized only if they are needed.<br>
</LI>
<LI> 
<B>Reducing the coupling between a subclass and its superclass(es)</b>. When subclasses access inherited fields only through their corresponding accessor member functions, it makes it possible to change the implementation of fields in the superclass without affecting any of its subclasses, effectively reducing coupling between them. Accessors reduce the risk of the "fragile base class" where changes in a superclass ripple throughout its subclasses.<br>
</LI>
<LI> 
<B>
Encapsulating changes to fields</b>. If the business rules pertaining to one or more fields change you can potentially modify your accessors to provide the same ability as before the change, making it easier for you to respond to the new business rules.<br>
</LI>
<LI> 
<B>
Simplifying concurrency issues.</b> [<A HREF="#LEA97">LEA97</a>] points out that setter member functions provide a single place to include a <I>notifyAll</I> if you have waits based on the value of that field. This makes moving to a concurrent solution much easier.<br>
</LI>
<LI> 
<B>
Name-hiding becomes less of an issue.</b> Although you should avoid name hiding, giving local variables the same names as fields, the use of accessors to always access fields means that you can give local variables any name you want. You do not have to worry about hiding field names because you never access them directly anyway.</LI>

</OL>
 
</small></font></small>
 
    
 
<h4>
    <b><font face="Arial" size="2"><a name="4.4.1.1    When not to use accessors">4.4.1.1&nbsp;&nbsp;&nbsp; When not
    to use accessors</a>&nbsp;</font></b> <A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a>
</h4>
	<FONT SIZE=3>
            
    <p>The only time that you might want to not use accessors is when execution time is of the utmost
    importance. However, it's a very rare case when the increased coupling within your application justifies this action.</p>
  
</font></BLOCKQUOTE><FONT SIZE=3><H3>
 <FONT FACE=ARIAL size="3">4.4.2&nbsp;&nbsp;&nbsp; <A NAME="Naming Accessors">Naming
 accessors</a> </font><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H3> 
</font><BLOCKQUOTE>
<P>
	Getter member functions should be given the name "get" + field name, unless the field represents a boolean (true or false), and then the getter is given the name "is" + field name. Setter member functions should be given the name "set" + field name, regardless of the field type
    ([<A HREF="#GOS96">GOS96</a>] and [<A HREF="#DES97">DES97</a>]). Note that the field name is always in mixed case with the first letter of all words capitalized. This naming convention is used consistently within the JDK and is required for beans development.
</P>
<B> 
<P>
	<BIG>Examples:</BIG></P></b>

<DIV ALIGN=CENTER><CENTER>
	<TABLE BORDER=1 CELLPADDING=7 CELLSPACING=1 WIDTH="85%" HEIGHT=278>
			<TR>
				<TH BGCOLOR="#ffffff" VALIGN=TOP WIDTH=109 HEIGHT=20 scope="col">
					<B><font face="Times New Roman" size="2">Field</font></B>
				</TH>
				<TH BGCOLOR="#ffffff" VALIGN=TOP WIDTH=133 HEIGHT=20 scope="col">
					<B><font face="Times New Roman" size="2">Type</font></B>
				</TH>
				<TH BGCOLOR="#ffffff" VALIGN=TOP WIDTH=149 HEIGHT=20 scope="col">
					<B><font face="Times New Roman" size="2">Getter name</font></B>
				</TH>
				<TH BGCOLOR="#ffffff" VALIGN=TOP WIDTH=148 HEIGHT=20 scope="col">
					<B><font face="Times New Roman" size="2">Setter name</font></B>
				</TH>
			</TR>
	<FONT SIZE=3>
            
<TR>
	<TD VALIGN=TOP WIDTH=109 HEIGHT=16>
<PRE><FONT FACE=TAHOMA SIZE=1><B>firstName</B></FONT></PRE>  
</TD>
<TD VALIGN=TOP WIDTH=133 HEIGHT=16>
<PRE><FONT FACE=TAHOMA SIZE=1><B>string</B></FONT></PRE>  
</TD>
<TD VALIGN=TOP WIDTH=149 HEIGHT=16>
<PRE><FONT FACE=TAHOMA SIZE=1><B>getFirstName()</B></FONT></PRE>  
</TD>
<TD VALIGN=TOP WIDTH=148 HEIGHT=16>
<PRE><FONT FACE=TAHOMA SIZE=1><B>setFirstName()</B></FONT></PRE>  
</TD>
</TR>
<TR>
	<TD VALIGN=TOP WIDTH=109 HEIGHT=51>
<PRE><FONT FACE=TAHOMA SIZE=1><B>address</B></FONT></PRE>  
</TD>
<TD VALIGN=TOP WIDTH=133 HEIGHT=51>
<PRE><FONT FACE=TAHOMA SIZE=1><B>Address </B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>object</B></FONT></PRE>  
</TD>
<TD VALIGN=TOP WIDTH=149 HEIGHT=51>
<PRE><FONT FACE=TAHOMA SIZE=1><B>getAddress()</B></FONT></PRE>  
</TD>
<TD VALIGN=TOP WIDTH=148 HEIGHT=51>
<PRE><FONT FACE=TAHOMA SIZE=1><B>setAddress()</B></FONT></PRE>  
</TD>
</TR>
<TR>
	<TD VALIGN=TOP WIDTH=109 HEIGHT=16>
<PRE><FONT FACE=TAHOMA SIZE=1><B>persistent</B></FONT></PRE>  
</TD>
<TD VALIGN=TOP WIDTH=133 HEIGHT=16>
<PRE><FONT FACE=TAHOMA SIZE=1><B>boolean</B></FONT></PRE>  
</TD>
<TD VALIGN=TOP WIDTH=149 HEIGHT=16>
<PRE><FONT FACE=TAHOMA SIZE=1><B>isPersistent()</B></FONT></PRE>  
</TD>
<TD VALIGN=TOP WIDTH=148 HEIGHT=16>
<PRE><FONT FACE=TAHOMA SIZE=1><B>setPersistent()</B></FONT></PRE>  
</TD>
</TR>
<TR>
	<TD VALIGN=TOP WIDTH=109 HEIGHT=16>
<PRE><FONT FACE=TAHOMA SIZE=1><B>customerNo</B></FONT></PRE>  
</TD>
<TD VALIGN=TOP WIDTH=133 HEIGHT=16>
<PRE><FONT FACE=TAHOMA SIZE=1><B>int</B></FONT></PRE>  
</TD>
<TD VALIGN=TOP WIDTH=149 HEIGHT=16>
<PRE><FONT FACE=TAHOMA SIZE=1><B>getCustomerNo()</B></FONT></PRE>  
</TD>
<TD VALIGN=TOP WIDTH=148 HEIGHT=16>
<PRE><FONT FACE=TAHOMA SIZE=1><B>setCustomerNo()</B></FONT></PRE>  
</TD>
</TR>
<TR>
	<TD VALIGN=TOP WIDTH=109 HEIGHT=51>
<PRE><FONT FACE=TAHOMA SIZE=1><B>orderItems</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B> </B></FONT></PRE> 
</TD>
<TD VALIGN=TOP WIDTH=133 HEIGHT=51>
<PRE><FONT FACE=TAHOMA SIZE=1><B>Array of </B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>OrderItem </B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>objects</B></FONT></PRE>  
</TD>
<TD VALIGN=TOP WIDTH=149 HEIGHT=51>
<PRE><FONT FACE=TAHOMA SIZE=1><B>getOrderItems()</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B> </B></FONT></PRE> 
</TD>
<TD VALIGN=TOP WIDTH=148 HEIGHT=51>
<PRE><FONT FACE=TAHOMA SIZE=1><B>setOrderItems()</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B> </B></FONT></PRE> 
</TD>
</TR>
</font></TABLE>
</CENTER>
</DIV>
</BLOCKQUOTE> <p>&nbsp;</p>  
 <H3><font face="ARIAL" size="3"><a name="4.4.3    Advanced techniques for accessors">4.4.3&nbsp;&nbsp;&nbsp; Advanced techniques for
 accessors</a> </font><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H3>  
<BLOCKQUOTE>

<P>
Accessors can be used for more than just getting and setting the values of instance fields. This section discusses how to increase the flexibility of your code by using accessors to: 
<UL>
	<LI>
        initialize the values of fields
	</LI>
	<LI>
        access constant values
	</LI>
	<LI>
        access collections
	</LI>
	<LI>
        access several fields simultaneously
	</LI>
</UL>
 
<H4> <B><FONT FACE=ARIAL size="2"> <a name="4.4.3.1    Lazy initialization">4.4.3.1&nbsp;&nbsp;&nbsp; Lazy initialization</a></font></b><B><font face="ARIAL" size="2">&nbsp;
</font></b><FONT SIZE=3><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a>

</font></H4> 

	
            
<P>
	Variables need to be initialized before they are accessed. There are two
    schools of thought to initialization: Initialize all variables at the time the object is created (the traditional approach) or initialize at the time
    it's first used.&nbsp;

</P>
 
<P>
 The first approach uses special member functions that are invoked when the object is first created, called constructors. Although this works, it often proves to be error-prone. When adding a new variable, you can easily forget to update the constructors.
</P>
 
<P>
    An alternative approach is called <I>lazy initialization</I> where fields are initialized by their getter member functions, as shown below.
    Note how a setter member function is used within the getter member function. Notice
    that the member function checks to see if the branch number is zero; if it is, then it sets it to the appropriate default value.</P>
 
</BLOCKQUOTE><FONT SIZE=3>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>/** Answers the branch number, which is the leftmost</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>four digits of the full account number.</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>Account numbers are in the format BBBBAAAAAA.</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>*/</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>protected int getBranchNumber()</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>{</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>if( branchNumber == 0)</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>{</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>// The default branch number is 1000, which</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>// is the main branch in downtown Bedrock.</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>setBranchNumber(1000);</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>}</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>return branchNumber;</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>}</B></FONT>
</P>
<SMALL> <BLOCKQUOTE> 
	<FONT SIZE=3>
		<P>
			It is quite common to use lazy initialization for fields that are actually other objects stored in the database. For example, when you create a new inventory item, you do not need to fetch whatever inventory item type from the database that you have set as a default. Instead, use lazy initialization to set this value the first time it is accessed, so that you only have to read the inventory item type object from the database when and if you need it.&nbsp;
		</P>
		<P>
 This approach is advantageous for objects that have fields that are not regularly accessed. Why incur the overhead of retrieving something from persistent storage if you are not going to use it?
		</P>
		<P>
			Whenever lazy initialization is used in a getter member function, you should document why the default value is what it is, as we saw in the example above. When you do this, you take the mystery out of how fields are used in your code,
            which improves both its maintainability and its extensibility.</P></font>

</BLOCKQUOTE>
</SMALL> 
<BLOCKQUOTE>
<H4> <B><FONT FACE=ARIAL size="2"><a name="4.4.3.2    Accessors for constants">4.4.3.2&nbsp;&nbsp;&nbsp;
Accessors for
constants</a></FONT></b>
<SMALL> <A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></H4> 
</BLOCKQUOTE><SMALL>
<BLOCKQUOTE>
<P>
	The common Java idiom is to implement constant values as static final fields. This approach makes sense for "constants" that are guaranteed to be stable. For example, the class <B>Boolean</B> implements two <I>static final</I> fields called <B>TRUE</B> and <B>FALSE</B>, which represents the two instances of that class. It would also make sense for a <B>DAYS_IN_A_WEEK</B> constant whose value probably is never going to change.
</P>
<P>
	However, many so-called business "constants" change over time because the business rules
    change. Consider the following example: The Archon Bank of Cardassia (ABC) has always insisted that an account has a minimum balance of $500 if it is to earn interest. To implement this, we could add a static field named <B>MINIMUM_BALANCE</B> to the class Account that would be used in the member functions that calculate interest. Although this would work, it is not flexible. What happens if the business rules change and different kinds of accounts have different minimum balances, perhaps $500 for savings accounts but only $200 for checking accounts? What would happen if the business rules were to change to a $500 minimum balance in the first year, $400 in the second, $300 in the third, and so on? Perhaps the rule will be changed to $500 in the summer, but
    to only $250 in the winter? Perhaps a combination of all of these rules will need to be implemented in the future.
</P>
<P>
	The point being made is that implementing constants as fields is not
    flexible. A much better solution is to implement constants as getter member functions. In our example above, a static (class) member function called <B>getMinimumBalance()</B> is far more flexible than a static field called <B>MINIMUM_BALANCE</B> because we can implement the various business rules in this member function and subclass it appropriately for various kinds of accounts.
</P>
 
</BLOCKQUOTE>
</SMALL> 
<BLOCKQUOTE>
<blockquote>
<PRE><FONT FACE=TAHOMA SIZE=1><B>/** Get the value of the account number. Account numbers are in the following </B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>    format: BBBBAAAAAA, where BBBB is the branch number and </B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>    AAAAAA is the branch account number.</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>*/</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>public long getAccountNumber()</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>{</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>	return ( ( getBranchNumber() * 100000 ) + getBranchAccountNumber() );</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>}</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>/**</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>	Set the account number. Account numbers are in the following </B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>	format: BBBBAAAAAA where BBBB is the branch number and</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>	AAAAAA is the branch account number.</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>*/</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>public void setAccountNumber(int newNumber)</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>{</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>	setBranchAccountNumber( newNumber % 1000000 );</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>	setBranchNumber( newNumber / 1000000 );</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>}</B></FONT></PRE> 
</blockquote>
</BLOCKQUOTE>
<BLOCKQUOTE>  
	<FONT SIZE=3>
 
		<P>
			Another advantage of constant getters is that they help to increase
            the consistency of your code. Consider the code shown above-it doesn't work properly. An account number is the concatenation of the branch number and the branch account number. Testing our code, we find that the setter member function, <B>setAccountNumber()</B> does not update branch account numbers properly;
            it takes the three leftmost digits, not four. That is because we used 1,000,000 instead of 100,000 to extract the field <B>branchAccountNumber</B>. Had we used a single source for this value, the constant getter <B>getAccountNumberDivisor()</B> as we see below, our code would have been more consistent and would have worked.
		</P>
       
</font> 
  <blockquote>
 <PRE><FONT FACE=TAHOMA SIZE=1><B>/**</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>	Returns the divisor needed to separate the branch account number from the </B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>	branch number within the full account number. </B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>	Full account numbers are in the format BBBBAAAAAA.</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>*/</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>public int getAccountNumberDivisor()</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>{</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>	return ( (long) 1000000);</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>}</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>/**</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>	Get the value of the account number. Account numbers are in the following </B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>	format: BBBBAAAAAA, where BBBB is the branch number and </B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>	AAAAAA is the branch account number.</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>*/</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>public long getAccountNumber()</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>{</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>	return ( ( getBranchNumber() * getAccountNumberDivisor() ) + getBranchAccountNumber() );</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>}</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>/**</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>	Set the account number. Account numbers are in the following </B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>	format: BBBBAAAAAA where BBBB is the branch number and</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>	AAAAAA is the branch account number.</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>*/</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>public void setAccountNumber(int newNumber)</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>{</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>	setBranchAccountNumber( newNumber % getAccountNumberDivisor() );</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>	setBranchNumber( newNumber / getAccountNumberDivisor() );</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>}</B></FONT></PRE> 
  </blockquote>
 <FONT SIZE=3> 
	<P>
		By using accessors for constants, we decrease the chance of bugs and, at the same time, increase the maintainability of our system. When the layout of an account number changes, and we know that it eventually will, chances are that our code will be easier to change because we have both hidden and centralized the information needed to
        build or divide account numbers.</P></FONT>

</BLOCKQUOTE>
<BLOCKQUOTE>
<H4><B> <FONT FACE=ARIAL size="2"><a name="4.4.3.3    Accessors for collections">4.4.3.3&nbsp;&nbsp;&nbsp;
Accessors for
collections</a></font></b>
<A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H4> 
</BLOCKQUOTE>
</font><BLOCKQUOTE>
<P>
	The main purpose of accessors is to encapsulate the access to fields
    to reduce the coupling within your code. Collections, such as arrays and vectors, being more complex than single value fields naturally need to have more than just the standard getter and setter member function implemented for them. In particular, because you can add and remove to and from collections, accessor member functions need to be included to do so. Add the following accessor member functions where appropriate for a field that is a collection:
</P>
<DIV ALIGN=CENTER><CENTER>
	<TABLE BORDER=1 CELLPADDING=7 CELLSPACING=1 HEIGHT=267 WIDTH="85%">
			<TR>
				<th BGCOLOR="#ffffff" HEIGHT=45 VALIGN=TOP scope="col" WIDTH="40%">
					<B><font face="Arial" size="1">Member Function type</font></B>
				</th>
				<th BGCOLOR="#ffffff" HEIGHT=45 VALIGN=TOP scope="col" WIDTH="27%">
					<B><font face="Arial" size="1">Naming convention</font></B>
				</th>
				<th BGCOLOR="#ffffff" HEIGHT=45 VALIGN=TOP scope="col" WIDTH="33%">
					<B><font face="Arial" size="1">Example</font></B>
				</th>
			</TR>
            
	<FONT SIZE=3>
            
	<FONT SIZE=3>
            
        <TR>
				<TD HEIGHT=19 VALIGN=TOP WIDTH="40%">
                    <font size="2">Getter for the collection</font>
				</TD>
<TD HEIGHT=19 VALIGN=TOP WIDTH="27%">
<PRE><FONT FACE=TAHOMA SIZE=1><B>getCollection()</B></FONT></PRE>  
</TD>
<TD HEIGHT=19 VALIGN=TOP WIDTH="33%">
<PRE><FONT FACE=TAHOMA SIZE=1><B>getOrderItems()</B></FONT></PRE>  
</TD>
</TR>
<TR> 
	<TD HEIGHT=19 VALIGN=TOP WIDTH="40%">
        <font size="2">Setter for the collection</font>
	</TD>
<TD HEIGHT=19 VALIGN=TOP WIDTH="27%">
<PRE><FONT FACE=TAHOMA SIZE=1><B>setCollection() </B></FONT></PRE>  
</TD>
<TD HEIGHT=19 VALIGN=TOP WIDTH="33%">
<PRE><FONT FACE=TAHOMA SIZE=1><B>setOrderItems()</B></FONT></PRE>  
</TD>
</TR>
<TR> 
	<TD HEIGHT=19 VALIGN=TOP WIDTH="40%">
        <font size="2">Insert an object into the collection</font>
	</TD>
<TD HEIGHT=19 VALIGN=TOP WIDTH="27%">
<PRE><FONT FACE=TAHOMA SIZE=1><B>insertObject()</B></FONT></PRE>  
</TD>
<TD HEIGHT=19 VALIGN=TOP WIDTH="33%">
<PRE><FONT FACE=TAHOMA SIZE=1><B>insertOrderItem()</B></FONT></PRE>  
</TD>
</TR>
<TR> 
	<TD HEIGHT=19 VALIGN=TOP WIDTH="40%">
        <font size="2">Delete an object from the collection</font>
	</TD>
<TD HEIGHT=19 VALIGN=TOP WIDTH="27%">
<PRE><FONT FACE=TAHOMA SIZE=1><B>deleteObject()</B></FONT></PRE>  
</TD>
<TD HEIGHT=19 VALIGN=TOP WIDTH="33%">
<PRE><FONT FACE=TAHOMA SIZE=1><B>deleteOrderItem()</B></FONT></PRE>  
</TD>
</TR>
<TR> 
	<TD HEIGHT=38 VALIGN=TOP WIDTH="40%">
        <font size="2">Create and add a new object into the collection</font>
	</TD>
<TD HEIGHT=38 VALIGN=TOP WIDTH="27%">
<PRE><FONT FACE=TAHOMA SIZE=1><B>newObject()</B></FONT></PRE>  
</TD>
<TD HEIGHT=38 VALIGN=TOP WIDTH="33%">
<PRE><FONT FACE=TAHOMA SIZE=1><B>newOrderItem()</B></FONT></PRE>  
</TD>
</TR>
</font></font></TABLE>
</CENTER>
</DIV>
<SMALL> <FONT SIZE=3> 
	<P>
		The advantage of this approach is that the collection is fully encapsulated, allowing you to later replace it with another structure, perhaps a linked list or a B-tree.</P></FONT>

</small></BLOCKQUOTE>
<BLOCKQUOTE>
<H4><FONT FACE=ARIAL size="2"> <B><a name="4.4.3.4    Accessing several fields simultaneously">4.4.3.4&nbsp;&nbsp;&nbsp;
Accessing
several fields simultaneously</a></b></font><SMALL>
<SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></H4> 
</BLOCKQUOTE><SMALL>
<BLOCKQUOTE>
<P>
	One of the strengths of accessor member functions is that they enable you to enforce business rules effectively. Consider, for example, a class hierarchy of shapes. Each subclass of <B>Shape</B> knows its position via the use of two fields "<B>xPosition</B> and <B>yPosition</B>" and can be moved on the screen on a two-dimensional plane
    by invoking the member function <B>move(Float xMovement, Float yMovement)</B>. For our purposes, it does not make sense to move a shape along one axis at a
    time; instead we'll move along both the x and the y axes simultaneously (it is acceptable to pass a value of 0.0 as for either parameter of the <B>move()</B> member function). The implication is that the <B>move()</B> member function should be public, but the member functions <B>setXPosition()</B> and <B>setYPosition()</B> should both be private, being invoked by the <B>move()</B> member function appropriately.
</P>
<P>
	An alternative implementation would be to introduce a setter member function that updates both fields at once, as shown below. The member functions <B>setXPosition()</B> and <B>setYPosition()</B> would still be private so that they may not be invoked directly by external classes or subclasses (you would want to add some documentation, shown below, indicating that they should not be directly invoked).
</P>

</BLOCKQUOTE>
  </SMALL> 
<BLOCKQUOTE>
<blockquote>
<PRE><FONT FACE=TAHOMA SIZE=1><B>/** Set the position of the shape */</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>protected void setPosition(Float x, Float y)</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>{</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>	setXPosition(x);</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>	setYPosition(y);</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>}</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>/** Set the x position.  Important: Invoke setPosition(), not this member function. */</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>private void setXPosition(Float x)</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>{</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>	xPosition = x;</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>}</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>/** Set the y position of the shape</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>    Important: Invoke setPosition(), not this member function.</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>*/</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>private void setYPosition(Float y)</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>{</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>	yPosition = y;</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>}</B></FONT></PRE> 
</blockquote>
</BLOCKQUOTE>
	<h2> <FONT FACE=ARIAL size="3"><a name="4.5    Visibility of accessors">4.5&nbsp;&nbsp;&nbsp;
    Visibility of
    accessors</a></font>
<SMALL> 
<SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></h2><SMALL> 
<BLOCKQUOTE>
<P>
	Always strive to make accessors protected, so that only subclasses can access the fields. Only when an "outside class" needs to access a field should you make the corresponding getter or setter public. Note that it's common that the getter member function be public and the setter protected.
</P>
<P>
	Sometimes you need to make setters private to ensure certain invariants hold. For example, an <B>Order</B> class may have a field representing a collection of <B>OrderItem</B> instances, and a second field called <B>orderTotal</B>, which is the total of the entire order. The <B>orderTotal</B> is a convenience field that is the sum or all
    subtotals of the ordered items. The only member functions that should update the value of <B>orderTotal</B> are those that manipulate the collection of order items. Assuming that those member functions are all implemented in <B>Order</B>, you should make <B>setOrderTotal()</B> private, even though <B>getOrderTotal()</B> is more than likely public.</P>
      </BLOCKQUOTE>

  </SMALL> 
<H2><FONT FACE=ARIAL size="3"> <B><a name="4.6    Always initialize static fields">4.6&nbsp;&nbsp;&nbsp; Always initialize static
fields</a></b></font><small><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></H2><small> 
<BLOCKQUOTE>
<P>
	Static fields, also known as class fields, should be given valid values because you cannot assume that instances of a class will be created before a static field is accessed.
</P>
<P>&nbsp;
    
</P>
</BLOCKQUOTE>
</small>
	<HR ALIGN=LEFT>
<H1><B><font face="ARIAL" size="4"><a name="5    Standards for Local Variables">5&nbsp;&nbsp;&nbsp; Standards for
Local
Variables</a></font></B><small><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></H1><small> 
<blockquote>
<P>
A local variable is an object or data item that is defined within the scope of a block, often a member function. The scope of a local variable is the block in which it is defined. The important coding standards for local variables focus on: 
<UL>
	<LI>
		Naming conventions
	</LI>
	<LI>
       
		Declarations and documentation conventions
	</LI>

</UL>
  </blockquote>


</small>
<H2> <FONT FACE=ARIAL size="3"><a name="5.1&nbsp;&nbsp;&nbsp; Naming local variables">5.1&nbsp;&nbsp;&nbsp;
Naming local variables</a> </font><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H2> 
<BLOCKQUOTE>
<P>
	In general, local variables are named following the same conventions used for
    fields; in other words, use full English descriptors with the first letter of any non-initial word in uppercase.
</P>
<P>
	For the sake of convenience, however, this naming convention is relaxed for several specific types of local variable: 
<UL>
	<LI>
		Streams
	</LI>
	<LI>
		Loop counters
	</LI>
	<LI>
        Exception objects</LI>
	
</UL>
</BLOCKQUOTE>
<H3> <FONT FACE=ARIAL size="3"><a name="5.1.1    Naming streams">5.1.1&nbsp;&nbsp;&nbsp;
Naming
streams</a></font><small><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></H3><small> 
<BLOCKQUOTE>
<P>
	When there is a single input and/or output stream being opened, used, and then closed within a member function, the common convention is to use <B>in</B> and <B>out</B> for the names of these streams, respectively [<A HREF="#GOS96">GOS96</a>]. For a stream used for both input and output, the implication is to use the name <B>inOut.</B>
</P>
<P>
	A common alternative to this naming convention, although conflicting with Sun's recommendations, is to use the names <B>inputStream</B>, <B>outputStream</B>, and <B>ioStream</B> instead of <B>in</B>, <B>out</B>, and <B>inOut</B> respectively.
</P>

</BLOCKQUOTE>
</small><H3> <FONT FACE=ARIAL size="3">5.1.2&nbsp;&nbsp;&nbsp; <A NAME="Naming Loop Counters">Naming
loop counters</a></font><small><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></H3><small> 
<BLOCKQUOTE>
<P>
	Because loop counters are a very common use for local variables, and because it was acceptable in C/C++, in Java programming the use of <B>i</B>, <B>j</B>, or <B>k</B>, is acceptable for loop counters [<A HREF="#GOS96">GOS96</a>]. If you use these names for loop counters, use them consistently.
</P>
<P>
	A common alternative is to use names like <B>loopCounter</B> or simply <b>counter</b>, but the problem with this approach is that you often find names like <B>counter1</B> and <B>counter2</B> in member functions that require more than one counter. The bottom line is that <B>i</B>, <B>j</B>, <B>k</B> work as
    counters;
    they're quick to type in and they're generally accepted.
</P>

</BLOCKQUOTE>
</small><H3> <FONT FACE=ARIAL><small>5.1.3&nbsp;&nbsp;&nbsp; <A NAME="Naming Exception Objects">Naming
exception objects</a></small></font><small><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></H3><small> 
<BLOCKQUOTE>
<P>
	Because exception handling is also very common in Java coding, the use of the letter <B>e</B> for a generic exception is considered acceptable [<A HREF="#GOS96">GOS96</a>].
</P>
</BLOCKQUOTE>
</small>
<H2><FONT FACE=ARIAL size="3"> <B>5.2&nbsp;&nbsp;&nbsp; <A NAME="Declaring and Documenting Local Variables">Declaring and
documenting local variables</a></b></font><small><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></H2><small> 
<BLOCKQUOTE>
<P>
	There are several conventions regarding the declaration and documentation of local variables in Java. These conventions are: 
	<OL>
	<LI> 
	<B>
		Declare one local variable per line of code.</b> This is consistent with one statement per line of code and makes it possible to document each variable with an inline comment.<br>
</LI>
<LI> 
<B>
Document local variables with an inline comment.</b> Inline commenting is a style,
where a single line comment, denoted by //, immediately follows a command on the same line of code (this is called an endline comment). You should document what a local variable is used for, where
its use is appropriate, and why it is used. This makes your code easier to understand.<br>
</LI>
<LI> 
<B>
Use local variables for one thing only.</b> Whenever you use a local variable for more than one reason, you effectively decrease its
cohesion and make it difficult to understand. You also increase the chances of introducing bugs into your code from the unexpected side effects of previous values of a
localvariable from earlier in the code. Yes, reusing local variables is more efficient because less memory needs to be allocated, but reusing local variables decreases the maintainability of your code and makes it more fragile. This usually is not worth the small savings
gained from not having to allocate more memory.</LI>

</OL>

</BLOCKQUOTE>
</small>
<H3> <FONT FACE=ARIAL size="3"><a name="5.2.1    General comments about declaration">5.2.1&nbsp;&nbsp;&nbsp; General comments about
declaration</a> </font><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H3> 
<small> 
<BLOCKQUOTE>
<P>
	Local variables that are declared between lines of code, for example, within the scope of an
    <b> if</b> statement, can be difficult to find by people who are not familiar with your code.
</P>
<P>
	One alternative to declaring local variables immediately before their first use is to instead declare them at the top of the code. Because your member functions should be short anyway, see
    section <a href="#3.5.5    Write short, single command lines">3.5.5, Write
    short, single command lines</a>, it should not be all that bad having to go to the top of your code to determine what the local variable is all about.</P>

      </BLOCKQUOTE>
</small>


	<HR ALIGN=LEFT>
<H1><B><font face="ARIAL" size="4">6&nbsp;&nbsp;&nbsp; Standards For <A NAME="Parameters to Member Functions">Parameters to
Member Functions</a></font></B><small><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></H1><small> <FONT SIZE=3> 
<blockquote>
<P>
	The standards that are important for parameters and arguments to member functions focus on how they are named and how they are documented. The term <I>parameter</I> is used to refer to a member function argument.</P>
</blockquote>
</font></small>


<H2><FONT FACE=ARIAL size="3"> <B>6.1&nbsp;&nbsp;&nbsp; <A NAME="Naming Parameters">Naming
parameters</a></b></font><small><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></H2><blockquote> 
<small>
<P>
Parameters should be named following the same conventions used for local variables. As with local variables, name hiding is an issue.
</P>
<B> 
<P>
	<BIG>Examples:</BIG></P></B>

</small>
</blockquote>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>customer</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>inventoryItem</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>photonTorpedo</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>in</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>e</B></FONT>
</P>
<SMALL> 
</SMALL> 
<blockquote>
<P>
	A viable alternative, taken from Smalltalk, is to use the naming conventions for local variables, with the addition of "a" or "an" on the front of the name.
    Adding "a" or "an" helps make the parameter stand out from local variables and fields, and avoids the name hiding problem. This is the preferred approach.
</P>
<SMALL> <B> 
	<P>
		<BIG>Examples:</BIG></P></B>

</SMALL> 
</blockquote>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>aCustomer</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>anInventoryItem</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>aPhotonTorpedo</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>anInputStream</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>anException</B></FONT>
</P>
 <H3><FONT FACE=ARIAL> <B><small>6.2&nbsp;&nbsp;&nbsp; <A NAME="Documenting Parameters">Documenting
 parameters</a></small></b></font><small><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></H3><blockquote> 

<P>
Parameters to a member function are documented in the header documentation for the member function using the <I>javadoc</I> <I>@param</I> tag. You should
describe the following: 
<OL>
<LI> 
<B>
	What it should be used for.</b>  You need to document what a parameter is used for, so that other developers understand the full context of how the parameter
will be used.<br>

</LI>
<LI> 
<B>
Any restrictions or  </b><B>preconditions. </B>If the full range of values for a parameter is not acceptable to a member function, then the invoker of that member function needs to know. Perhaps a member function only accepts positive
numbers or strings of less than five characters.<br>

</LI>
<LI> 
<B>
Examples.</b> If it isn't completely obvious what a parameter should be, then you should provide one or more examples in the documentation.
</LI>
</OL>
</blockquote>
<h3>
	<B><font size="3" face="Arial"><a name="6.2.1    Use interfaces for parameter types">6.2.1&nbsp;&nbsp;&nbsp; Use interfaces for
    parameter types</a> </font></B>
    <A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a>
</h3>
<blockquote>

<P>
    Instead of specifying a class, such as <B>Object</B>, for the type of a parameter, if appropriate specify an interface, such as <B>Runnable</B>. The advantage is that this approach, depending on the situation, can be more specific (Runnable is more specific than Object), or potentially
    may be a better way to support polymorphism. Instead of insisting on a parameter being an instance of a class in a specific class hierarchy, specify that it supports a specific interface implying that it only needs to be polymorphically compliant to what you
    need.
</P>

</blockquote>
	<HR ALIGN=LEFT>
<H1><font face="ARIAL" size="4"><b>7&nbsp;&nbsp;&nbsp; <A NAME="Standards For Classes, Interfaces, Packages and Compilation Units">Standards
for Classes, Interfaces, Packages, and Compilation Units</a></b></font><small><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></H1><small> <FONT SIZE=3> 
<blockquote>
<P>
	This chapter concentrates on standards and guidelines for classes, interfaces, packages, and compilation units. A class is a template from which objects are instantiated (created). Classes contain the declaration of fields and member functions. Interfaces are the definition of a common signature, including both member functions and fields, which a class that implements an interface must support. A package is a collection of related classes. Finally, a compilation unit is a source code file in which classes and interfaces are declared. Because Java allows compilation units to be stored in a database, an individual compilation unit may not directly relate to a physical source code file.</P>
</blockquote>
</font></small>


<H2><FONT FACE=ARIAL size="3"> <B>7.1&nbsp;&nbsp;&nbsp; <A NAME="Standards for Classes">Standards for
classes</a> </b></font><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H2> 
 
<BLOCKQUOTE>
<P>
	The standards that are important for classes are based on: 
	

<UL>
		<LI>
            naming conventions
		</LI>
       
		<LI>
            documentation conventions
		</LI>
        
		<LI>
            declaration conventions
		</LI>
        
		<LI>
            the public and protected interface</LI>

</UL>
</BLOCKQUOTE>
<H3> <FONT FACE=ARIAL size="3">7.1.1&nbsp;&nbsp;&nbsp; <A NAME="Naming Classes">Naming
classes</a> </font><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H3> 
<BLOCKQUOTE>
<P>
	The standard Java convention uses a full English descriptor, starting with the first letter capitalized
    and using mixed case for the rest of the name. ([<A HREF="#GOS96">GOS96</a>]
    and [<A HREF="#AMB98">AMB98</a>])</P>
<P>
	Class names must be in the singular form.</P>





<B> 
<P>
    <font size="3">Examples:</font>
</P>

	<FONT SIZE=3>
            
	<FONT SIZE=3>
            
</font></font></B>  
</BLOCKQUOTE><FONT SIZE=3><FONT SIZE=3>   
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>Customer</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>Employee</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>Order</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>OrderItem</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>FileStream</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>String</B></FONT>
</P>
 <H3> <FONT FACE=ARIAL size="3">7.1.2&nbsp;&nbsp;&nbsp; <A NAME="Documenting a Class">Documenting a
class</a></font><small><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></H3> 
<BLOCKQUOTE>
  
<P>
The following information should appear in the documentation comments immediately preceding the definition of a class: 
<OL>
<LI> 
<B>
	The purpose of the class.</b> Developers need to know the general purpose of a class so they can determine whether or not it meets their needs. Make it a habit to document any good things to know about a
class; for example, is it part of a pattern or are there any interesting limitations to using it [<A HREF="#AMB98">AMB98</a>]?<br>
</LI>

  
<LI> 
<B>
Known bugs</b>. If there are any outstanding problems with a class, they should be documented so that other developers understand the
weaknesses and difficulties with the class. Furthermore, the reason for not fixing the bug also
needs to be documented. Note that if a bug is specific to a single member function, then it should be directly associated with the member function instead.<br>
</LI>
<LI> 
<B>
The development or maintenance history of the class.</b> It's common practice to include a history table listing dates, authors, and summaries of changes made to a class.
This provides maintenance programmers insight into any modifications made to a class in the
past and documents who has done what to a class.<br>
</LI>
<LI> 
<B>
Document applicable invariants.</b> An invariant is a set of assertions about an instance or class that must be true at all "stable" times, where a stable time is defined as the period before a member function is invoked on the
object or class and immediately after a member function is invoked [<A HREF="#MEY88">MEY88</a>]. By documenting the invariants of a class, you provide valuable insight to other developers
about how a class can be used.<br>
</LI>
<LI> 
<B>
The concurrency strategy</b>. Any class that implements the interface <B>Runnable</B> should have its concurrency strategy fully described. Concurrent programming is a complex topic that's new for many programmers, therefore you need to invest the extra time to ensure that people can understand your work. It's important to document your concurrency strategy and why you chose that strategy over others. Common concurrency strategies [<A HREF="#LEA97">LEA97</a>] include the following:</LI>

</OL><FONT SIZE=3>
  <blockquote>
    <ul>
      <li>synchronized objects</li>
      <li>balking objects</li>
      <li>guarded objects</li>
      <li>versioned objects</li>
      <li>concurrency policy controllers</li>
      <li>acceptors</li>
    </ul>
  </blockquote>
</font>

  </BLOCKQUOTE>
<H3> <FONT FACE=ARIAL size="3">7.1.3&nbsp;&nbsp;&nbsp; <A NAME="Class Declarations">Class
declarations</a></font>
<A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H3> 
<BLOCKQUOTE>
  
<P>
One way to make your classes easier to understand is to declare them in a consistent manner. The common approach in Java is to declare a class in the following order:
</P>
<BLOCKQUOTE>
<ul>
  <li>
		public member functions</li>
  <li>
		public fields</li>
  <li>
		protected member functions</li>
  <li>
		protected fields</li>
  <li>
		private member functions</li>
  <li>
		private fields</li>
</ul>
</BLOCKQUOTE>
<P>
[<A HREF="#LAF97">LAF97</a>] points out constructors and <B>finalize()</B> should be listed first, presumably because these are the first member functions that another developer will look at to understand how to use the class. Furthermore, because we have a standard to declare all fields as private, the declaration order really
comes down to:
</P>
<BLOCKQUOTE>

	<P>
		constructors
	</P>
 <PRE><FONT FACE=TAHOMA SIZE=1><B>finalize()</B></FONT></PRE> 
	<P>
		public member functions
	</P>
<P>
	protected member functions
</P>
<P>
private member functions
</P>
<P>
private fields
</P>
        </BLOCKQUOTE>
       
<P>
Within each grouping of member functions, it's common to list them in alphabetical order. Many developers choose to list the static member functions within each grouping first, followed by instance member
functions; and then within each of these two sub-groupings, list the member functions alphabetically. Both of these approaches are
valid; you just need to choose one and stick to it.
</P>
</BLOCKQUOTE><H3> <font size="3"> <FONT FACE=ARIAL>7.1.4&nbsp;&nbsp;&nbsp;
<A NAME="_Toc386368622"></a><A NAME="_Toc386369021"></a><A NAME="Minimize the Public and Protected Interface">Minimize the
public and protected interface</a></font> <A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></font></H3> 
</font></font><BLOCKQUOTE><FONT SIZE=3><FONT SIZE=3>
<P>
One of the fundamentals of object-oriented design is to minimize the public interface of a class. There are several reasons for this: 
<OL>
<LI> 
<B>Ease of learning.</b> To learn how to use a class, you should only have to understand its public interface. The smaller the public interface, the easier a class is to learn.<br>
</LI>
<LI> 
<B>
Reduced coupling.</b> Whenever the instance of one class sends a message to an instance of another class, or directly to the class itself, the two classes become coupled. Minimizing the public interface implies that you are minimizing the opportunities for coupling.<br>
</LI>
<LI> 
<B>
Greater flexibility.</b> This is directly related to coupling. Whenever you want to change the way that a member function in your public interface is
implemented-perhaps you want to modify what the member function returns-then you potentially have to modify any code that invokes the member function. The smaller the public interface; the greater the encapsulation; and, therefore, the greater your flexibility.
</LI>
</OL>
<P>
It's clear that it's worth your while to minimize the public interface, but often what is not so clear is that you also want to minimize the protected interface as well. The basic idea is that, from the point of view of a subclass, the protected interfaces of all of its superclasses are effectively public. Any member function in the protected interface can be invoked by a subclass. Therefore, you want to minimize the protected interface of a class for the same reasons that you want to minimize the public interface.</P>
        </FONT> </font> 
        <h4>
<B><font size="2" face="Arial"><a name="7.1.4.1    Define the public interface first">7.1.4.1&nbsp;&nbsp;&nbsp; Define the public
interface first</a> </font></B>
<FONT SIZE=3><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a>

</font>
</h4>
	
            
    <P>Most experienced developers define the public interface of a class before they begin coding it.&nbsp;
</P>
<ul>
  <li> First, if you don't know what services or behaviors a class will perform, then you still have some design work to do.
  </li>
  <li> Second, it enables you to stub out the class quickly so that other developers who rely on it can at least work with the stub until the "real" class has been developed.&nbsp;<br>
   
  </li>
  <li> Third, this approach provides you with an initial framework around which to build your class.
  </li>
</ul>
</BLOCKQUOTE>
<H2><b><font face="ARIAL" size="3">7.2&nbsp;&nbsp;&nbsp; </font></b><A NAME="Standards for Interfaces"><B><font face="ARIAL" size="3">Standards for
interfaces</font></B></a>
<A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H2> 
<BLOCKQUOTE>
<P>
	The standards that are important for interfaces are based on: 
	<UL>
		<LI>
			Naming conventions
		</LI>
		<LI>
			Documentation conventions</LI>

</UL>
</BLOCKQUOTE>

<H3> <FONT FACE=ARIAL size="3">7.2.1&nbsp;&nbsp;&nbsp; <A NAME="Naming Interfaces">Naming
interfaces</a></font>
<A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H3> 
<BLOCKQUOTE>
<P>
The Java convention is to name interfaces using mixed case, with the first letter of each word capitalized. The preferred Java convention for the name of an interface is to use a descriptive adjective, such as <B>Runnable</B> or <B>Cloneable</B>, although descriptive nouns, such as <B>Singleton</B> or <B>DataInput</B>, are also common [<A HREF="#GOS96">GOS96</a>].
</P>
</BLOCKQUOTE>

<BLOCKQUOTE>
<B> <h4><font face="Arial" size="2"><a name="7.2.1.1    Alternative">7.2.1.1&nbsp;&nbsp;&nbsp; Alternative</a>
</font><FONT SIZE=3><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a>
</font>
</h4> </B> 
</BLOCKQUOTE>
	<FONT SIZE=3>
            
<BLOCKQUOTE>
	<FONT SIZE=3><P> 
		<B>
			Prefix the letter "I" to the interface name.</b>  As [<A HREF="#COA97">COA97</a>] suggests, appending the letter "I" to the front of an interface
        names results in names like <B>ISingleton</B> or <B>IRunnable</B>. This approach helps to distinguish interface names from class and package names. I like this potential naming convention for the simple fact that it makes your class diagrams, sometimes referred to as object models, easier to read. The main disadvantage is that the existing interfaces, such as <B>Runnable</B>, are not named using this approach. This interface naming convention is also popular for Microsoft's COM/DCOM architecture.</P></FONT>

</BLOCKQUOTE>
<H3> <FONT FACE=ARIAL size="3">7.2.2&nbsp;&nbsp;&nbsp; <A NAME="Documenting Interfaces">Documenting
interfaces</a></font><small><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></H3><small> 
<BLOCKQUOTE>
<P>
	The following information should appear in the documentation comments immediately preceding the definition of an interface:
</P>
 
</BLOCKQUOTE>
<BLOCKQUOTE>
 
<OL>
<LI> 
<b>State the purpose.</b> Before other developers will use an interface, they need to understand the concept that it encapsulates. In other words, they need to know its purpose. A really good test of whether or not you need to define an interface is whether or not you can easily describe its purpose. If you have difficulties describing it, then chances are pretty good you don't need the interface to begin with. Because the concept of interfaces is new to Java, people are not yet experienced in their appropriate use and they're likely to overuse them because they
are new.<br>
</LI>
<LI> 
<B>
How interfaces should and should not be used.</b> Developers need to know both how an interface is to be used, as well as how it should not be used [<A HREF="#COA97">COA97</a>].
</LI>
</OL>

</BLOCKQUOTE>
<BLOCKQUOTE>

<P>
	Because the signature for member functions is defined in an interface, for each member function signature you
    need to follow the member function documentation conventions discussed in <a href="#Standards For Member Functions">Chapter
    3</a>.</P>

</BLOCKQUOTE>

<H2><FONT FACE=ARIAL size="3"> <B>7.3&nbsp;&nbsp;&nbsp; <A NAME="Standards for Packages">Standards for
packages</a> </b></font><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H2> 
<BLOCKQUOTE>
<P>
	The standards that are important for packages are based on: 
	
<UL>
		<LI>
            naming conventions
		</LI>
    
		<LI>
            documentation conventions</LI>

</UL>
</BLOCKQUOTE>

<H3> <FONT FACE=ARIAL size="3">7.3.1&nbsp;&nbsp;&nbsp; <A NAME="Naming Packages">Naming
packages</a></font><font face="ARIAL"> </font><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H3> 
<BLOCKQUOTE>
<P>
	There are several rules associated with naming packages. In order, these rules are: 
	<OL>
	<LI> 
	<B>
		Identifiers are separated by periods.</b> To make package names more readable, Sun suggests that the identifiers in package names be separated by periods. For example, the package name <B>java.awt</B> is comprised of two identifiers, <B>java</B> and <B>awt</B>.<br>
</LI>
<LI> 
<B>
The standard Java distribution packages from Sun begin with the identifier "java".</b> Sun has reserved this right so that the standard
Java packages are named in a consistent manner, regardless of the vendor of your Java development environment.<br>
</LI>
<LI> 
<B>
Local package names begin with an identifier that is not all uppercase.</b> Local packages are used internally within your organization and will not be distributed to other organizations. Examples of these package names include <B>persistence.mapping.relational</B> and<B> interface.screens</B>.<br>
</LI>
<LI> 
<B>
Global package names begin with the reversed Internet domain name for your organization.</b> A package that
will be distributed to multiple organizations should include the originating organization's domain name, with the top-level domain type capitalized. For example, to distribute the previous packages, they would be named <B>com.rational.www.persistence.mapping.relational</B> and <B>com.rational.www.interface.screens</B>.0</LI>

</OL>
</BLOCKQUOTE>
</small>
<H3> <FONT FACE=ARIAL size="3">7.3.2&nbsp;&nbsp;&nbsp; <A NAME="Documenting Packages">Documenting
packages</a></font><small><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></H3><small> 
<BLOCKQUOTE>
<P>
	You should maintain one or more external documents that describe the purpose of the packages developed by your organization. For each package, you should document: 
	<OL>
	<LI> 
	<B>
		The rationale for the package.</b> Other developers need to know what a package is all about so they can determine whether or not they want to use
    it and, if it is a shared package, whether or not they want to enhance or extend it.<br>
</LI>
<LI> 
<B>
The classes in the package.</b> Include a list of the classes and interfaces in the package with a brief, one-line description of each so that other developers know what the package contains.
</LI>
</OL>
<P>
<b><i>Tip</i></b>: Create an HTML file using the name of the package and put it in the appropriate directory for the package. The file shall be postfixed with <I>.html</I>.</P>

</BLOCKQUOTE>
</small>
<H2><FONT FACE=ARIAL size="3"> <B>7.4&nbsp;&nbsp;&nbsp; <A NAME="Standards for Compilation Units">Standards for
compilation units</a></b></font><small><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></H2> 
<BLOCKQUOTE>
<P>
	The standards and guidelines for compilation units are based on: 
	<UL>
		<LI>
			Naming conventions
		</LI>
		<LI>
            Documenting conventions</LI>

</UL>
  
</BLOCKQUOTE>
<H3><font face="Arial" size="3">7.4.1&nbsp;&nbsp;&nbsp; </font><A NAME="Naming Compilation Units"><font face="Arial" size="3">Naming
compilation units</font></a><SMALL>
<SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></H3> 
  
<BLOCKQUOTE>
<P>
	A compilation unit, in this case a source code file, should be given the name of the primary class or interface that is declared within it. Use the same name for the
    package or class for the file name, using the same case. The extension <B>.java</B> should be postfixed to the file name.
</P>
<B> 
<P>
	<BIG>Examples:</BIG>
</P>
</B>  
</BLOCKQUOTE> 
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>Customer.java</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>Singleton.java</B></FONT>
</P>
<P CLASS=EXAMPLE>
	<FONT FACE=TAHOMA SIZE=1><B>SavingsAccount.java</B></FONT>
</P>
 <H3> <FONT FACE=ARIAL size="3">7.4.2&nbsp;&nbsp;&nbsp; <A NAME="Documenting Compilation Units">Documenting
compilation units</a></font><small><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></H3> 
<BLOCKQUOTE>
 
<P>
Although you should strive to have only one class or interface declaration per file, it sometimes makes sense to define several classes (or interfaces) in the same file. A general rule of thumb is that if the sole purpose of class B is to encapsulate functionality needed only by class A, then it makes sense that class B appears in the same source code file as class A. As a result, the following documentation conventions apply to a source code
file and not specifically to a class: 
<OL>
<LI> 
<B>
	For files with several classes, list each class.</b> If a file contains more than one class, you should provide a list of the classes and a brief description for each.<br>
</LI>
<LI> 
<B>
The file name and/or identifying information.</b> The name of the file should be included at the top of it. The advantage is that if the code is printed, you know what the source file for the code is.<br>
</LI>
<LI> 
<B>
Copyright information.</b> If applicable, you should indicate any copyright information for the file. It's common to indicate the year of the copyright and the name of the
individual or organization holding the copyright. Note that the code author may not be the holder of the copyright.</LI>

</OL>
</BLOCKQUOTE>



	<HR ALIGN=LEFT>
<H1><b><font face="ARIAL" size="4">8&nbsp;&nbsp;&nbsp; </font></b><A NAME="Error Handling and Exceptions"><B><font face="ARIAL" size="4">Error
Handling and Exceptions</font></B></a><SMALL>
<SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></H1>  
<BLOCKQUOTE>
	<P>
		The general philosophy is to use exceptions only for errors: logic and programming errors, configuration errors, corrupted data, resource exhaustion,
        and so forth. The general rule is that the systems, in normal conditions and in the absence of overload or hardware failure, should not raise any exceptions.
	</P>
    <ol>
      <li>
		<b>Use exceptions to handle logic and programming errors, configuration errors, corrupted data,
        and resource exhaustion</b>.&nbsp;
      </li>
    </ol>
    <blockquote>
	<P>
		 Report exceptions by the appropriate logging mechanism as early as possible, including at the point
        they're raised.
	</P>
    </blockquote>
    <ol start="2">
      <li>
		<b>Minimize the number of exceptions exported from a given abstraction.</b>
      </li>
    </ol>
	<BLOCKQUOTE>
		<P>
			In large systems, handling a large number of exceptions at each level makes the code difficult to read and maintain. Sometimes the exception processing dwarfs the normal processing.
		</P>
		<P>
			There are several ways to minimize the number of exceptions: 
		<UL>
			<LI>
				Export only a few exceptions but provide "diagnosis" primitives that allow querying the faulty abstraction or the bad object for more detailed information about the nature of the problem that occurred.
			</LI>
		</UL>
		<UL>
			<LI>
				Add "exceptional" states to the objects, and provide primitives to explicitly
                check the validity of the objects.
			</LI>
		</UL>
	</BLOCKQUOTE>
    <ol start="3">
      <li>
		<b>Do not use exceptions for frequent, anticipated events.</b>
      </li>
    </ol>
	<BLOCKQUOTE>
		<P>
			There are several inconveniences in using exceptions to represent conditions that are not clearly errors:
		<UL>
			<LI>
				It is confusing.
			</LI>
			<LI>
				It usually forces some disruption in the flow of control that is more difficult to understand and to maintain.
			</LI>
			<LI>
				It makes the code more painful to debug, since most source-level debuggers flag all exceptions by default.
			</LI>
		</UL>
		<P>
			For instance, do not use an exception as some form of extra value returned by a function (like Value_Not_Found in a search); use a procedure with an "out" parameter, or introduce a special value meaning Not_Found, or pack the returned type in a record with a discriminant Not_Found.
		</P>
	</BLOCKQUOTE>
    <ol start="4">
      <li>
		<b>Do not use exceptions to implement control structures.</b>
      </li>
    </ol>
	<BLOCKQUOTE>
		<P>
			This is a special case of the previous rule: exceptions should not be used as a form of "goto" statement.
		</P>
	</BLOCKQUOTE>
    <ol start="5">
      <li>
		<b>Make sure status codes have an appropriate value.</b>
      </li>
    </ol>
	<BLOCKQUOTE>
		<P>
			When using status code returned by subprograms as an "out" parameter, always make sure a value is assigned to the "out" parameter by making this the first executable statement in the subprogram body. Systematically make all statuses a success by default or a failure by default. Think of all possible exits from the subprogram, including exception handlers.
		</P>
	</BLOCKQUOTE>
    <ol start="6">
      <li>
		<b>Perform safety checks locally; do not expect your client to do so.</b>
      </li>
    </ol>
	<BLOCKQUOTE>
		<P>
            If a subprogram might produce erroneous output unless given proper input, install code in the subprogram to detect and report invalid input in a controlled manner. Do not rely on a comment that tells the client to pass proper values. It's virtually guaranteed that sooner or later that comment will be ignored, resulting in hard-to-debug errors if the invalid parameters are not detected.
		</P>
	</BLOCKQUOTE>
</BLOCKQUOTE>
	<HR ALIGN=LEFT>
<H1><B><font face="ARIAL" size="4">9&nbsp;&nbsp;&nbsp; <A NAME="Miscellaneous">Miscellaneous</a> 
 Standards and Issues</font></B>
<SMALL> 
    <SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></H1><SMALL> 
<BLOCKQUOTE>
<P>
	This chapter describes several important standards and
    guidelines that are general enough that they need their own chapter.
</P>
 
</BLOCKQUOTE>
</SMALL><H2><FONT FACE=ARIAL size="3"> <B><a name="9.1    Reusing">9.1&nbsp;&nbsp;&nbsp;
Reusing</a>
</b></font>
<SMALL> 
    <A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a> 
</SMALL></H2> 
<SMALL> 
<BLOCKQUOTE>
<P>
	Any Java class library or package that you purchase or reuse from an external source should be certified as 100% pure Java [<A HREF="#SUN97">SUN97</a>]. By enforcing this standard you are guaranteed that what you are reusing will work on all platforms you choose to deploy it on. You can obtain Java classes, packages, or applets from a variety of sources, either a third-party development company that specializes in Java libraries, or another division or project team within your organization.
</P>
 
</BLOCKQUOTE>
</SMALL>
<H2><FONT FACE=ARIAL size="3"> <B>9.2&nbsp;&nbsp;&nbsp; <A NAME="Importing Classes">Importing
classes</a></b></font>
<SMALL> 
    <SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></H2> 
<BLOCKQUOTE><SMALL>
<P>
	The import statement allows the use of wildcards when indicating the names of classes. For example, the statement
</P>
 </small>
 <BLOCKQUOTE>
 <PRE><FONT FACE=TAHOMA SIZE=1><B>import java.awt.*;</B></FONT></PRE> 
 </BLOCKQUOTE>
<P>
	brings in all of the classes in the package <B>java.awt</B> at once. Actually, that's not completely true. What really happens is
    that every class you use from the <B>java.awt</B> package will be brought into your code when it's
    compiled; classes that you do not use will not be. Although this sounds like a good feature, it reduces the readability of your code. A better approach is to fully qualify the name of the classes that your code uses [<A HREF="#LAF97">LAF97</a>]; [<A HREF="#VIS96">VIS96</a>]. A better way to import classes is shown in the example below:
</P>
<BLOCKQUOTE>
<PRE><FONT SIZE=1 FACE=TAHOMA><B>import java.awt.Color</B></FONT></PRE> <PRE><FONT SIZE=1 FACE=TAHOMA><B>import java.awt.Button</B></FONT></PRE> <PRE><FONT SIZE=1 FACE=TAHOMA><B>import java.awt.Container</B></FONT></PRE> 
</BLOCKQUOTE>
</BLOCKQUOTE>
	<H2><FONT FACE=ARIAL size="3"> <b>9.3&nbsp;&nbsp;&nbsp; </b><A NAME="Optimizing Java Code"><B>Optimizing Java
    code</B></a></font>
<SMALL> 
<A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></small></H2><BLOCKQUOTE> 

<P>
	Optimizing your code is one of the last things that programmers should be thinking about, not one of the first.
    Leave optimization to the end because you want to optimize only the code that needs it. Very often a small percentage of your code results in the vast majority of the processing time, and this is the code that you should be optimizing. A classic mistake made by inexperienced programmers is to try to optimize all of their code, even code that already runs fast enough.</P>

</BLOCKQUOTE>
<SMALL> 
<BLOCKQUOTE>
<ol>
  <li>
	<b>Do not waste your time optimizing code that nobody cares about!</b>
  </li>
</ol>
<BLOCKQUOTE>
	
	<P>
		What should you look for when optimizing code? As [<A HREF="#KOE97">KOE97</a>] points out, the most important factors are fixed overhead and performance on large inputs. The reason for this is simple: fixed overhead dominates the
        runtime speed for small inputs and the algorithm dominates for large inputs.
        Koenig's rule of thumb is that a program that works well for both small and large inputs will likely work well for medium-sized inputs.
	</P>
<P>
	Developers who have to write software that works on several hardware platforms and/or operating systems need to be aware of idiosyncrasies in the various platforms. Operations that might appear to take a particular amount of time, such as the way that memory and buffers are handled, often show substantial variations between platforms. It is common to find that you need to optimize your code differently, depending on the platform.</P>

<P>
	Another issue to be aware of when optimizing code is the priorities of your users, because people will be sensitive to particular
    delays, depending on the context. For example, your users will likely be happier with a screen that draws itself immediately and then takes eight seconds to load data
    rather than with a screen that draws itself after taking five seconds to load data. In other words, most users are willing to wait a little longer as long as they're given immediate feedback-important knowledge to have when optimizing your code.
</P>
</BLOCKQUOTE>
<ol start="2">
  <li>
	<b>You do not always need to make your code run faster to optimize it in the eyes of your users.</b>
</li>
</ol>
 
<BLOCKQUOTE>
	<P>
		Although optimization may mean the difference between the success and failure of your application, never forget that it's far more important to get your code to work properly. Never forget that slow software that works is always preferable to fast software that does not.
	</P>
</BLOCKQUOTE>
</BLOCKQUOTE>
</SMALL>
<H2><FONT FACE=ARIAL size="3"> <B>9.4&nbsp;&nbsp;&nbsp; <A NAME="Writing Java Test Harnesses">Writing Java
test harnesses</a></b></font>
<A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H2> 
<BLOCKQUOTE>
<P>
	Object-oriented testing is a critical topic that has been all but ignored by the object development community. The reality is that either you or someone else will have to test the software that you write, regardless of the language you have chosen to work in. A test harness is the collection of member functions, some embedded in the classes themselves
    (called built-in tests) and some in specialized testing classes, that is used to test your application. 
	<OL>
	<LI> 
	<B>
		Prefix all testing member function names with "test".</b> This allows you to quickly find all the testing member functions in your code. The advantage of prefixing the name of test member functions with "test" is that it allows you to easily strip your testing member functions out of your source code before compiling the production version of it.<br>
</LI>
<LI> 
<B>
Name all member function test member functions consistently. </b>Method testing is the act of verifying that a single member function performs as defined. All member function test member functions should be named following the format "<B>testMemberFunctionNameForTestName</B>". For example, the test harness member functions to test <B>withdrawFunds()</B> would include <B>testWithdrawFundsForInsufficientFunds()</B> and <B>testWithdrawFundsForSmallWithdrawal()</B>. If you have a series of tests for <B>withdrawFunds()</B>, you may choose to write a member function called <B>testWithdrawFunds()</B> that invokes all of them.<br>
</LI>
<LI> 
<B>
Name all class test member functions consistently. </b>Class testing is the act of verifying that a single class performs as defined. All class test member functions should be named following the format "<B>testSelfForTestName</B>". For example, the test harness member functions to test the Account class <B>testSelfForSimultaneousAccess()</B> and <B>testSelfForReporting()</B>.<br>
</LI>
<LI> 
<B>
Create a single point for invoking the tests for a class.</b> Develop a static member function called<B> testSelf() </B>that invokes all class testing and method testing member functions.<br>
    </LI>

  <li> 
<B>
	Document your test harness member functions.</b> Document your test harness member functions. The documentation should include a description of the test as well as the expected results of the test.
</li>

</OL>
</BLOCKQUOTE>
	<HR ALIGN=LEFT>
<H1><b><font face="ARIAL" size="4">10&nbsp;&nbsp;&nbsp; </font></b><A NAME="Patterns of Success"><B><font face="ARIAL" size="4">Patterns of
Success</font></B></a><FONT SIZE=3>
<A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></font></H1><FONT SIZE=3> 
<BLOCKQUOTE>
        <P> Having a standards document in your possession does not automatically 
          make you more productive as a developer. To be successful, you must 
          choose to become more productive and that means you must apply these 
          standards effectively. </P>
</BLOCKQUOTE>
<H2><FONT FACE=ARIAL size="3"> <B><a name="10.1    Using these standards effectively">10.1&nbsp;&nbsp;&nbsp; Using these standards
effectively</a></b></font><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H2> 
<BLOCKQUOTE>
<P>
	The following words of advice will help you use the Java coding standards and guidelines described in this
    document more effectively.
</P>
</BLOCKQUOTE>
<BLOCKQUOTE>
<OL>
<LI> 
<B>
	Understand the standards.</b> Take the time to understand why each standard and guideline leads to greater productivity. For example, do not declare each local variable on its own line just because these guidelines told you
to. Do it because you understand that it increases the understandability of your code.<br>
</LI>
<LI> 
<B>
Believe in them.</b> Understanding each standard is a start, but you also need to believe in them too. Following standards should not be something you do when you have the
time; it should be something that you always do because you believe that this is the best way to code.<br>
</LI>
<LI> 
<B>
Follow them while you are coding, not as an afterthought.</b> Documented code is easier to understand
when you are writing it and after it is written. Consistently named member functions and fields are easier to work with during
both development and maintenance. Clean code is easier to work with both during development and maintenance. The bottom line is that following standards will increase your productivity, while you are developing,
and will make your code easier to maintain (thereby making maintenance developers more productive too). If you write clean code from the
beginning, you can benefit from it while you are creating it.<br>
</LI>
<LI> 
<B>
Make them part of your quality assurance process.</b> Part of a code inspection should be to ensure that source code follows the standards adopted by your organization. Use standards as the basis from which you train and mentor your developers to become more effective.
</LI>
</OL>
</BLOCKQUOTE>
<H2><FONT FACE=ARIAL size="3"> <B><a name="10.2    Other factors that lead to writing successful code">10.2&nbsp;&nbsp;&nbsp; Other factors that lead to
writing successful code</a></b></font><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H2> 
<BLOCKQUOTE>
<OL>
<LI> 
<B>
	Program for people, not the machine.</b> The primary goal of your development efforts should be that your code is easy for other people to understand. If no one else can figure it out, then it isn't any good. Use naming conventions. Document your code. Paragraph it.<br>
</LI>
<LI> 
<B>
Design first, then code.</b> Have you ever been in a situation where some of the code that your program relies on needs to be changed? Perhaps a new parameter needs to be passed to a member function, or perhaps a class needs to be
divided into several classes. How much extra work did you have to do to make sure that your code works with the reconfigured version of the modified code? How happy were you? Did you ask yourself why somebody didn't stop and think about it first when he or she originally wrote the code so that this didn't need to
happen
or that they should have <i>DESIGNED</i> it first? Of course you did. If you take the time to figure out how you are going to write your code before you actually start coding, you will probably spend less time writing it. Furthermore, you potentially
will reduce the impact of future changes on your code simply by thinking about them up front.<br>
</LI>
<LI> 
<B>
Develop in small steps.</b> Developing in small steps-writing a few member functions, testing them, and then writing a few more member functions-is often far more effective than writing a whole bunch of code all at once and then trying to fix it. It is much easier to test and fix ten lines of code than
100; in fact, it is safe to say that you could program, test, and fix 100 lines of code in ten 10-line increments in less than half the time than you could write a single one-hundred line block of code that did the same work.&nbsp;
<br>
 The reason for this is simple. Whenever you are testing your code and you find a bug, you almost always find the bug in the new code that you just
wrote (assuming of course that the rest of the code was pretty solid to begin
with). You can hunt down a bug a lot faster in a small section of code than in a big one. By developing in small incremental steps, you reduce the average time that it takes to find a bug, which in turn reduces your overall development time.<br>
</LI>
<LI> 
<B>
Keep your code simple.</b> Complex code might be intellectually satisfying to write but if other people can't understand it then it isn't any good. The first time that someone, perhaps even you, is asked to modify a piece of complex code to either fix a bug or to enhance it, chances are pretty good that the code will get rewritten. In fact, you've probably even had to rewrite somebody else's code because it was too hard to understand. What did you think of the original developer when you rewrote their
code? Did you think that person was a genius or a jerk? Writing code that needs to be rewritten later is nothing to be proud of, so follow the KISS rule: Keep it simple, stupid.<br>
</LI>
<LI>
	<B>Learn common patterns, antipatterns, and idioms.</B> There is a wealth of analysis, design, and process patterns and antipatterns, as well as programming idioms, available to guide you in increasing your development productivity. See <A HREF="/process/referenc.htm#AMB98">[AMB98]</a> and <A HREF="/process/referenc.htm#AMB99">[AMB99]</a> for more information.
</LI>
</OL>
</BLOCKQUOTE>
</FONT>
	<HR ALIGN=LEFT>
<H1><b><font face="ARIAL" size="4">11&nbsp;&nbsp;&nbsp; </font></b><A NAME="Summary"><B><font face="ARIAL" size="4">Summary</font></B></a><FONT SIZE=3>
<SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></font></H1><FONT SIZE=3> 
<BLOCKQUOTE>
<P>
	This chapter summarizes the guidelines given herein for your convenience and
    is organized into several one-page summaries of our Java coding standards, collected by topic. These topics are:
</P>
<UL>
	<LI>
		Java naming conventions
	</LI>
	<LI>
		Java documentation conventions
	</LI>
	<LI>
		Java coding conventions
	</LI>
</UL>
<P>
	Before we summarize the rest of the standards and guidelines described in this white paper, I would like to reiterate the prime directive:
</P>
</BLOCKQUOTE>
<BLOCKQUOTE>
<P>
	<B>When you go against a standard, document it.</B> All standards, except for this one, can be broken. If you do so, you must document why you broke the standard, the potential implications of breaking the standard, and any conditions that may/must occur before the standard can be applied to this situation.
</P>
</BLOCKQUOTE>
<H2><FONT FACE=ARIAL size="3"> <B>11.1&nbsp;&nbsp;&nbsp; <A NAME="Java Naming Conventions">Java
naming conventions</a></b></font><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H2> 
</FONT></font><BLOCKQUOTE><FONT SIZE=3><FONT SIZE=3>
<P>
	With a few exceptions discussed below, you should always use full English descriptors when naming things. Furthermore, you should use lower case letters in general, but capitalize the first letter of class names and interface names, as well as the first letter of any non-initial word.
</P>
<B> 
<P>
    General Concepts:</B> 

<UL>
	<LI>
		Use full English descriptors.
	</LI>
	<LI>
		Use terminology applicable to the domain.
	</LI>
	<LI>
		Use mixed case to make names readable.
	</LI>
	<LI>
		Use short forms sparingly, but if you do so then use them intelligently.
	</LI>
	<LI>
		Avoid long names (less than 15 characters is a good idea).
	</LI>
	<LI>
		Avoid names that are similar or differ only in case.
	</LI>
	<LI>
		Avoid underscores.
	</LI>
</UL>
</font></font><DIV ALIGN=CENTER><CENTER><TABLE BORDER=1 CELLPADDING=7 CELLSPACING=1 WIDTH="85%">
			<TR>
				<TH BGCOLOR="#ffffff" VALIGN=TOP WIDTH="16%" scope="col">
					<B><font face="Arial" size="1">Item</font></B>
				</TH>
				<TH BGCOLOR="#ffffff" VALIGN=TOP WIDTH="58%" scope="col">
					<B><font face="Arial" size="1">Naming Convention</font></B>
				</TH>
				<TH BGCOLOR="#ffffff" VALIGN=TOP WIDTH="26%" scope="col">
					<B><font face="Arial" size="1">Example</font></B>
				</TH>
			</TR>
	<FONT SIZE=3>
	<FONT SIZE=3>
            
    <TR>
				<TD VALIGN=TOP WIDTH="16%">
                    <font size="2">Arguments/<br>
						parameters</font>
			</TD>
			<TD VALIGN=TOP WIDTH="58%">
                <font size="2">Use a full English description of value/object being passed, possibly prefixing the name with "a" or "an". The important thing is to choose one approach and stick to it.</font>
			</TD>
<TD VALIGN=TOP WIDTH="26%">
<PRE><FONT FACE=TAHOMA SIZE=1><B>customer, account,
               - or -
aCustomer, anAccount</B></FONT></PRE> 
</TD>
</TR>
<TR> 
		<TD VALIGN=TOP WIDTH="16%">
            <font size="2">Fields/<br>
				fields/<br>
			properties</font>
</TD>
<TD VALIGN=TOP WIDTH="58%">
    <font size="2">Use a full English description of the field, with the first letter in lower case and the first letter of any non-initial word in uppercase.</font>
</TD>
<TD VALIGN=TOP WIDTH="26%">
<PRE><FONT FACE=TAHOMA SIZE=1><B>firstName, lastName, 
warpSpeed</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B> </B></FONT></PRE> 
</TD>
</TR>
<TR> 
		<TD VALIGN=TOP WIDTH="16%">
            <font size="2">Boolean getter member functions</font>
		</TD>
		<TD VALIGN=TOP WIDTH="58%">
            <font size="2">All boolean getters must be prefixed with the word "is". If you follow the naming standard for boolean fields described above then you simply give it the name of the field.</font>
		</TD>
<TD VALIGN=TOP WIDTH="26%">
<PRE><FONT FACE=TAHOMA SIZE=1><B>isPersistent(), isString(), 
isCharacter() </B></FONT></PRE>   
</TD>
</TR>
<TR> 
		<TD VALIGN=TOP WIDTH="16%">
            <font size="2">Classes</font>
		</TD>
		<TD VALIGN=TOP WIDTH="58%">
            <font size="2">Use a full English description, with the first letters of all words capitalized.</font>
		</TD>
<TD VALIGN=TOP WIDTH="26%">
<PRE><FONT FACE=TAHOMA SIZE=1><B>Customer, SavingsAccount</B></FONT></PRE>  
</TD>
</TR>
</font></font><TR><FONT SIZE=3><FONT SIZE=3> 
		<TD VALIGN=TOP WIDTH="16%">
            <font size="2">Compilation unit files</font>
		</TD>
		</font></font><TD VALIGN=TOP WIDTH="58%"><FONT SIZE=3><FONT SIZE=3>
            <font size="2">Use the name of the class or interface, or if there is more than one class in the file than the primary class, ended with ".java" to indicate it</font></font></font><font size="2">'</font><FONT SIZE=3><font size="2">s a source code file.</font>
		</font></TD>
<TD VALIGN=TOP WIDTH="26%">
<PRE><FONT FACE=TAHOMA SIZE=1><B>Customer.java, </B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>SavingsAccount.java,</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>Singleton.java</B></FONT></PRE>  
</TD>
</TR>
<TR> 
		<TD VALIGN=TOP WIDTH="16%">
            <font size="2">Components/<br>
				widgets</font>
	</TD>
	<TD VALIGN=TOP WIDTH="58%">
        <font size="2">Use a full English description that 
        describes what the component is used for,
        with the type of the component concatenated onto the end.</font>
	</TD>
<TD VALIGN=TOP WIDTH="26%">
<PRE><FONT FACE=TAHOMA SIZE=1><B>okButton, customerList, </B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>fileMenu</B></FONT></PRE>  
</TD>
</TR>
<TR> 
		<TD VALIGN=TOP WIDTH="16%">
            <font size="2">Constructors</font>
		</TD>
		<TD VALIGN=TOP WIDTH="58%">
            <font size="2">Use the name of the class.</font>
		</TD>
<TD VALIGN=TOP WIDTH="26%">
<PRE><FONT FACE=TAHOMA SIZE=1><B>Customer(), SavingsAccount()</B></FONT></PRE>  
</TD>
</TR>
<TR> 
		<TD VALIGN=TOP WIDTH="16%">
            <font size="2">Destructors</font>
		</TD>
		<TD VALIGN=TOP WIDTH="58%">
            <font size="2">Java does not have destructors, but instead will invoke the <B>finalize()</B> member function before an object is garbage collected.</font>
		</TD>
<TD VALIGN=TOP WIDTH="26%">
<PRE><FONT FACE=TAHOMA SIZE=1><B>finalize()</B></FONT></PRE>  
</TD>
</TR>
<TR> 
		<TD VALIGN=TOP WIDTH="16%">
            <font size="2">Exceptions</font>
		</TD>
		<TD VALIGN=TOP WIDTH="58%">
            <font size="2">It is generally accepted to use the letter "e" to represent exceptions.</font>
		</TD>
<TD VALIGN=TOP WIDTH="26%">
<PRE><FONT FACE=TAHOMA SIZE=1><B>e</B></FONT></PRE>  
</TD>
</TR>
<TR> 
		<TD VALIGN=TOP WIDTH="16%">
            <font size="2">Final static fields (constants)</font>
		</TD>
		<TD VALIGN=TOP WIDTH="58%">
            <font size="2">Use all uppercase letters with the words separated by underscores. A better approach is to use final static getter member functions because
            they greatly increases flexibility.</font>
		</TD>
<TD VALIGN=TOP WIDTH="26%">
<PRE><FONT FACE=TAHOMA SIZE=1><B>MIN_BALANCE, DEFAULT_DATE</B></FONT></PRE>  
</TD>
</TR>
<TR> 
		<TD VALIGN=TOP WIDTH="16%">
            <font size="2">Getter member functions</font>
		</TD>
		<TD VALIGN=TOP WIDTH="58%">
            <font size="2">Prefix the name of the field being accessed with "get".</font>
		</TD>
<TD VALIGN=TOP WIDTH="26%">
<PRE><FONT FACE=TAHOMA SIZE=1><B>getFirstName(), getLastName(), </B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>getWarpSpeeed()</B></FONT></PRE>  
</TD>
</TR>
<TR> 
		<TD VALIGN=TOP WIDTH="16%">
            <font size="2">Interfaces</font>
		</TD>
		<TD VALIGN=TOP WIDTH="58%">
            <font size="2">Use a full English description describing the concept that the interface encapsulates, with the first letters of all words capitalized. It is customary to postfix the name with either "able", "ible", or "er" but this is not required.</font>
		</TD>
<TD VALIGN=TOP WIDTH="26%">
<PRE><FONT FACE=TAHOMA SIZE=1><B>Runnable, Contactable, </B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>Prompter, Singleton</B></FONT></PRE>  
</TD>
</TR>
<TR> 
		<TD VALIGN=TOP WIDTH="16%">
            <font size="2">Local variables</font>
		</TD>
		<TD VALIGN=TOP WIDTH="58%">
            <font size="2">Use full English descriptions with the first letter in lowercase but do not hide existing fields/fields. For example, if you have a field named
            &quot;firstName&quot;, do not have a local variable called
            &quot;firstName&quot;.</font>
		</TD>
<TD VALIGN=TOP WIDTH="26%">
<PRE><FONT FACE=TAHOMA SIZE=1><B>grandTotal, customer, </B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>newAccount</B></FONT></PRE>  
</TD>
</TR>
<TR> 
		<TD VALIGN=TOP WIDTH="16%">
            <font size="2">Loop counters</font>
		</TD>
		<TD VALIGN=TOP WIDTH="58%">
            <font size="2">It is generally accepted to use the letters <B>i</B>, <B>j</B>, or <B>k</B>, or the name <B>counter</B>.</font>
		</TD>
<TD VALIGN=TOP WIDTH="26%">
<PRE><FONT FACE=TAHOMA SIZE=1><B>i, j, k, counter</B></FONT></PRE>  
</TD>
</TR>
<TR> 
		<TD VALIGN=TOP WIDTH="16%">
            <font size="2">Packages</font>
		</TD>
		<TD VALIGN=TOP WIDTH="58%">
            <font size="2">Use full English descriptions, using mixed case with the first letter of each word in uppercase,
            and everything else in lower case. For global packages, reverse the name of your Internet domain and concatenate the package
            name to this.</font>
		</TD>
<TD VALIGN=TOP WIDTH="26%">
<PRE><FONT FACE=TAHOMA SIZE=1><B>java.awt,</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>com.ambysoft.www.</B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>persistence.mapping</B></FONT></PRE>  
</TD>
</TR>
<TR> 
		<TD VALIGN=TOP WIDTH="16%">
            <font size="2">Member Functions</font>
		</TD>
		<TD VALIGN=TOP WIDTH="58%">
            <font size="2">Use a full English description of what the member function does, starting with an active verb whenever possible, with the first letter in lowercase.</font>
		</TD>
<TD VALIGN=TOP WIDTH="26%">
<PRE><FONT FACE=TAHOMA SIZE=1><B>openFile(), addAccount()</B></FONT></PRE>  
</TD>
</TR>
<TR> 
		<TD VALIGN=TOP WIDTH="16%">
            <font size="2">Setter member functions</font>
		</TD>
		<TD VALIGN=TOP WIDTH="58%">
            <font size="2">Prefix the name of the field being accessed with "set".</font>
		</TD>
<TD VALIGN=TOP WIDTH="26%">
<PRE><FONT FACE=TAHOMA SIZE=1><B>setFirstName(), setLastName(), </B></FONT></PRE> <PRE><FONT FACE=TAHOMA SIZE=1><B>setWarpSpeed()</B></FONT></PRE>  
</TD>
</TR>
</TABLE>
</CENTER>
</DIV>
</BLOCKQUOTE>
<H2>
					<B><font face="ARIAL" size="3">11.2&nbsp;&nbsp;&nbsp; <A NAME="Java Documentation Conventions">Java
                    documentation conventions</a></font> <FONT SIZE=3> 
 <FONT FACE=ARIAL> 
				<I>
                    <A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></i></font>
</FONT></b></H2> 
 <FONT SIZE=3> 
<BLOCKQUOTE>
	<P>
		A really good rule of thumb to follow regarding documentation is to ask yourself if you have never seen the code
        before is, &quot;what information would you need to effectively understand the code in a reasonable amount of
        time?&quot;
	</P>
 
	<B> 
    <P>
        General Concepts:</B> 
 
<UL>
	<LI>
		Comments should add to the clarity of your code.
	</LI>
	<LI>
		If your program is not worth documenting, it probably is not worth running.
	</LI>
	<LI>
		Avoid decoration; that is, do not use banner-like comments.
	</LI>
	<LI>
		Keep comments simple.
	</LI>
	<LI>
		Write the documentation before you write the code.
	</LI>
	<LI>
		Document why something is being done, not just what's being done.
	</LI>
</UL>
</BLOCKQUOTE>
</FONT>
<H3> <font face="ARIAL" size="3">11.2.1&nbsp;&nbsp;&nbsp; </font><A NAME="Java Comment Types"><font face="ARIAL" size="3">Java
comment types</font></a> 
 <FONT SIZE=3> 
 <FONT FACE=ARIAL> </font><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></font></H3><BLOCKQUOTE> 
<FONT SIZE=3>
<P>
	The following chart describes the three types of Java comments and suggested uses for them.
</P>
</font>
<DIV ALIGN=CENTER>
	<CENTER>
		<TABLE BORDER=1 CELLPADDING=7 CELLSPACING=1 WIDTH="85%">
			<TR>
				<TH BGCOLOR="#ffffff" VALIGN=TOP WIDTH="21%" scope="col">
					<B><font face="Arial" size="1">Comment Type</font></B>
				</TH>
				<TH BGCOLOR="#ffffff" VALIGN=TOP WIDTH="40%" scope="col">
					<B><font face="Arial" size="1">Usage</font></B>
				</TH>
				<TH BGCOLOR="#ffffff" VALIGN=TOP WIDTH="40%" scope="col">
					<B><font face="Arial" size="1">Example</font></B>
				</TH>
			</TR>
			<TR>
				<TD VALIGN=TOP WIDTH="21%">
                    <font size="2">Documentation</font>
				</TD>
				<TD VALIGN=TOP WIDTH="40%">
                    <font size="2">Use documentation comments immediately before declarations of interfaces, classes, member functions, and fields to document them. Documentation comments are processed by <I>javadoc</I>, see below, to create external documentation for a class.</font>
				</TD>
				<TD VALIGN=TOP WIDTH="40%">
                    <font size="2">/**<br>
						Customer: A customer is any person or organization that we sell services and products to.<br>
					@author S.W. Ambler<br>
				*/</font> 
	</TD>
</TR>
<TR>
	<TD VALIGN=TOP WIDTH="21%">
        <font size="2">C style</font>
	</TD>
	<TD VALIGN=TOP WIDTH="40%">
        <font size="2">Use C-style comments to document out lines of code that are no longer applicable, but that you want to keep just in case your users change their minds, or because you want to temporarily turn it off while debugging.</font>
	</TD>
	<TD VALIGN=TOP WIDTH="40%">
        <font size="2">/*<br>
			This code was commented out by B.Gustafsson, June 4 1999 because it was replaced by the preceding code. Delete it after two years if it is still not applicable.<br>
		. . . (the source code )<br>
	*/</font> 
</TD>
</TR>
<TR>
	<TD VALIGN=TOP WIDTH="21%">
        <font size="2">Single line</font>
	</TD>
	<TD VALIGN=TOP WIDTH="40%">
        <font size="2">Use single line comments internally within member functions to document business logic, sections of code, and declarations of temporary variables.</font>
	</TD>
	<TD VALIGN=TOP WIDTH="40%">
        <font size="2">// Apply a 5% discount to all invoices<br>
			// over $1000 as defined by the Sarek<br>
		// generosity campaign started in<br>
	// Feb. of 1995.</font> 
</TD>
</TR>
</TABLE>
</CENTER>
</DIV>
</BLOCKQUOTE>
 <FONT SIZE=3> 
<H3> <FONT FACE=ARIAL size="3">11.2.2&nbsp;&nbsp;&nbsp; <A NAME="What To Document">What
to document</a></font><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H3> 
</FONT><BLOCKQUOTE><SMALL><FONT SIZE=3>
<P>
	The following chart summarizes what to document regarding each portion of Java code that you write.
</P>
</font></small><DIV ALIGN=CENTER><CENTER><TABLE BORDER=1 CELLPADDING=7 CELLSPACING=1 WIDTH="85%">
			<TR>
				<TD BGCOLOR="#ffffff" VALIGN=TOP WIDTH="21%">
					<B><font face="Arial" size="1">Item</font></B>
				</TD>
				<TD BGCOLOR="#ffffff" VALIGN=TOP WIDTH="79%">
					<B><font face="Arial" size="1">What to Document</font></B>
				</TD>
			</TR>
    <TR>
				<TD VALIGN=TOP WIDTH="21%">
                    <font size="2">Arguments/<br>
						parameters</font>
			</TD>
      <TD VALIGN=TOP WIDTH="79%"><font size="2">The type of the parameter</font> 
				<P>
                    <font size="2">
					What it should be used for</font>
				</P>
				<P>
                    <font size="2">
					Any restrictions or preconditions</font>
				</P>
				<P>
                    <font size="2">
					Examples</font>
				</P>
</TD>
</TR>
<TR>
	<TD VALIGN=TOP WIDTH="21%">
        <font size="2">Fields/<br>
			fields/properties</font>
</TD>
<TD VALIGN=TOP WIDTH="79%">
    <font size="2">Its description</font> 
	<P>
        <font size="2">
		Document all applicable invariants</font>
	</P>
<P>
    <font size="2">
	Examples</font>
</P>
<P>
<font size="2">
Concurrency issues</font>
</P>
<P>
<font size="2">
Visibility decisions</font>
</TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH="21%">
    <font size="2">Classes</font>
</TD>
<TD VALIGN=TOP WIDTH="79%">
    <font size="2">The purpose of the class</font> 
	<P>
        <font size="2">
		Known bugs</font>
	</P>
<P>
    <font size="2">
	The development and maintenance history of the class</font>
</P>
<P>
<font size="2">
Document applicable invariants</font>
</P>
<P>
<font size="2">
The concurrency strategy</font>
</TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH="21%">
    <font size="2">Compilation units</font>
</TD>
<TD VALIGN=TOP WIDTH="79%">
    <font size="2">Each class or interface defined in the class, including a brief description</font> 
	<P>
        <font size="2">
		The file name and/or identifying information</font>
	</P>
<P>
    <font size="2">
	Copyright information</font>
</TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH="21%">
    <font size="2">Getter member function</font>
</TD>
<TD VALIGN=TOP WIDTH="79%">
    <font size="2">Document why lazy initialization was used, if applicable</font>
</TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH="21%">
    <font size="2">Interfaces</font>
</TD>
<TD VALIGN=TOP WIDTH="79%">
    <font size="2">The purpose</font> 
	<P>
        <font size="2">
		How it should and should not be used</font>
</TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH="21%">
    <font size="2">Local variables</font>
</TD>
<TD VALIGN=TOP WIDTH="79%">
    <font size="2">Its use or purpose</font>
</TD>
</TR>
    <TR>
<TD VALIGN=TOP WIDTH="21%">
    <font size="2">Member Functions: Documentation</font>
</TD>
      <TD VALIGN=TOP WIDTH="79%"><font size="2">What and why the member function does what it does</font> 
	<P>
        <font size="2">
		What a member function must be passed as parameters</font>
	</P>
<P>
    <font size="2">
	What a member function returns</font>
</P>
<P>
<font size="2">
Known bugs</font>
</P>
<P>
<font size="2">
Any exceptions that a member function throws</font>
</P>
<P>
<font size="2">
Visibility decisions</font>
</P>
<P>
<font size="2">
How a member function changes the object</font>
</P>
<P>
<font size="2">
Include a history of any code changes</font>
</P>
<P>
<font size="2">
Examples of how to invoke the member function if appropriate</font>
</P>
        <P><font size="2">
Applicable preconditions and postcondition</font>
</TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH="21%">
    <font size="2">Member Functions: Internal comments</font>
</TD>
<TD VALIGN=TOP WIDTH="79%">
    <font size="2">Control structures</font> 
	<P>
        <font size="2">
		Why, as well as what, the code does</font>
	</P>
<P>
    <font size="2">
	Local variables</font>
</P>
<P>
<font size="2">
Difficult or complex code</font>
</P>
<P>
<font size="2">
The processing order</font>
</TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH="21%">
    <font size="2">Package</font>
</TD>
<TD VALIGN=TOP WIDTH="79%">
    <font size="2">The rationale for the package</font> 
	<P>
        <font size="2">
		The classes in the package</font>
</TD>
</TR>
</TABLE>
</CENTER>
</DIV>
</BLOCKQUOTE>
	<H2><FONT FACE=ARIAL size="3"><b>11.3&nbsp;&nbsp;&nbsp; </b><A NAME="Java Coding Conventions (General)"><B>Java
    coding conventions (general)</B></a></FONT><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H2> 
<BLOCKQUOTE>
	<P>
		There are many conventions and standards which are critical to the maintainability and enhancability of your Java code. 99.9% of the time it is more important to program for people, your fellow developers, than it is to program for the machine. Making your code understandable to others is of utmost importance.
	</P>
	<DIV ALIGN=CENTER>
		<CENTER>
			<TABLE BORDER=1 CELLPADDING=7 CELLSPACING=1 WIDTH="85%">
				<TR>
					<TH BGCOLOR="#ffffff" VALIGN=TOP WIDTH="17%" scope="col">
						<B><font face="Arial" size="1">Convention Target</font></B>
					</TH>
					<TH BGCOLOR="#ffffff" VALIGN=TOP WIDTH="83%" scope="col">
						<B><font face="Arial" size="1">Convention</font></B>
					</TH>
				</TR>
				<TR>
					<TD VALIGN=TOP WIDTH="17%">
                        <font size="2">Accessor member functions</font>
					</TD>
					<TD VALIGN=TOP WIDTH="83%">
                        <font size="2">Consider using lazy initialization for fields in the database</font> 
						<P>
                            <font size="2">
							Use accessors for obtaining and modifying all fields</font>
						</P>
					<P>
                        <font size="2">
						Use accessors for "constants"</font>
					</P>
				<P>
                    <font size="2">
					For collections, add member functions to insert and remove items</font>
				</P>
			<P>
                <font size="2">
				Whenever possible, make accessors protected, not public</font>
	</TD>
</TR>
<TR>
	<TD VALIGN=TOP WIDTH="17%">
        <font size="2">Fields</font>
	</TD>
	<TD VALIGN=TOP WIDTH="83%">
        <font size="2">Fields should always be declared private</font> 
		<P>
            <font size="2">
			Do not directly access fields, instead use accessor member functions</font>
		</P>
	<P>
        <font size="2">
		Do not use final static fields (constants), instead use accessor member functions</font>
	</P>
<P>
    <font size="2">
	Do not hide names</font>
</P>
<P>
<font size="2">
Always initialize static fields</font>
</TD>
</TR>
<TR>
	<TD VALIGN=TOP WIDTH="17%">
        <font size="2">Classes</font>
	</TD>
	<TD VALIGN=TOP WIDTH="83%">
        <font size="2">Minimize the public and protected interfaces</font> 
		<P>
            <font size="2">
			Define the public interface for a class before you begin coding it</font>
		</P>
	<P>
        <font size="2">
		Declare the fields and member functions of a class in the following order:</font><UL>
		<LI>
            <font size="2">
			constructors</font>
		</LI>
<LI>
<b><font face="TAHOMA" size="1">finalize()</font></b>
</LI>
<LI>
    <font size="2">
	public member functions</font>
</LI>
<LI>
<font size="2">
protected member functions</font>
</LI>
<LI>
<font size="2">
private member functions</font>
</LI>
<LI>
<font size="2">
private field</font></LI>

</UL>
</TD>
</TR>
<TR>
	<TD VALIGN=TOP WIDTH="17%">
        <font size="2">Local variables</font>
	</TD>
	<TD VALIGN=TOP WIDTH="83%">
        <font size="2">Do not hide names</font> 
		<P>
            <font size="2">
			Declare one local variable per line of code</font>
		</P>
	<P>
        <font size="2">
		Document local variables with an inline comment</font>
	</P>
<P>
    <font size="2">
	Declare local variables immediately before their use</font>
</P>
<P>
<font size="2">
Use local variables for one thing only</font>
</TD>
</TR>
<TR>
	<TD VALIGN=TOP WIDTH="17%">
        <font size="2">Member Functions</font>
	</TD>
	<TD VALIGN=TOP WIDTH="83%">
        <font size="2">Document your code</font> 
		<P>
            <font size="2">
			Paragraph your code</font>
		</P>
	<P>
        <font size="2">
		Use whitespace, one line before control structures and two before member function declarations</font>
	</P>
<P>
    <font size="2">
	A member function should be understandable in less than thirty seconds</font>
</P>
<P>
<font size="2">
Write short, single command lines</font>
</P>
<P>
<font size="2">
Restrict the visibility of a member function as much as possible</font>
</P>
<P>
<font size="2">
Specify the order of operations</font>
</TD>
</TR>
</TABLE>
</CENTER>
</DIV>
</BLOCKQUOTE>
	<HR ALIGN=LEFT>
<H1><font face="Arial" size="4">12&nbsp;&nbsp;&nbsp; </font><A NAME="References"><font face="Arial" size="4">References</font></a><SMALL> </SMALL><A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H1> 
<BLOCKQUOTE>
<DIV ALIGN=CENTER>
	<CENTER>
		<TABLE BORDER=0 WIDTH="85%">
			<TR>
			  <TH VALIGN=TOP scope="col">Ref Code </TH>
			  <TH scope="col">Ref Information </TH>
		  </TR>
			<TR>
				<TD VALIGN=TOP WIDTH="10%">
					[<A NAME="AMB98">AMB98</a>]
				</TD>
				<TD WIDTH="90%">
					Ambler, S.W. (1998)<I>. Building Object Applications That Work: Your Step-By-Step Handbook for Developing Robust Systems with Object Technology</I>. New York: SIGS Books/Cambridge University Press.
				</TD>
			</TR>
			<TR>
				<TD VALIGN=TOP WIDTH="10%">
					[<A NAME="COA97">COA97</a>]
				</TD>
				<TD WIDTH="90%">
					Coad, P. and Mayfield, M. (1997). <I>Java Design: Building Better Apps &amp; Applets</I>. Upper Saddle River, NJ: Prentice Hall Inc.
				</TD>
			</TR>
			<TR>
				<TD VALIGN=TOP WIDTH="10%">
					[<A NAME="DES97">DES97</a>]
				</TD>
				<TD WIDTH="90%">
					DeSoto, A. (1997). <I>Using the Beans Development Kit 1.0 February 1997: A Tutorial</I>. Sun Microsystems.
				</TD>
			</TR>
			<TR>
				<TD VALIGN=TOP WIDTH="10%">
					[<A NAME="GOS96">GOS96</a>]
				</TD>
				<TD WIDTH="90%">
					Gosling, J., Joy, B., Steele, G. (1996). <I>The Java Language Specification</I>. Reading, MA: Addison Wesley Longman Inc.
				</TD>
			</TR>
			<TR>
				<TD VALIGN=TOP WIDTH="10%">
					[<A NAME="GRA97">GRA97</a>]
				</TD>
				<TD WIDTH="90%">
					Grand, M. (1997). <I>Java Language Reference</I>. Sebastopol, CA: O. Reilly &amp; Associates, Inc.
				</TD>
			</TR>
			<TR>
				<TD VALIGN=TOP WIDTH="10%">
					[<A NAME="KAN97">KAN97</a>]
				</TD>
				<TD WIDTH="90%">
					Kanerva, J. (1997). <I>The Java FAQ</I>. Reading, MA: Addison Wesley Longman Inc.
				</TD>
			</TR>
			<TR>
				<TD VALIGN=TOP WIDTH="10%">
					[<A NAME="KOE97">KOE97</a>]
				</TD>
				<TD WIDTH="90%">
					Koenig, A. (1997). <I>The Importance--and Hazards--of Performance Measurement</I>. New York: SIGS Publications, Journal of Object-Oriented Programming, January, 1997, 9(8), pp. 58-60.
				</TD>
			</TR>
			<TR>
				<TD VALIGN=TOP WIDTH="10%">
					[<A NAME="LAF97">LAF97</a>]
				</TD>
				<TD WIDTH="90%">
					Laffra, C. (1997). <I>Advanced Java: Idioms, Pitfalls, Styles and Programming Tips</I>. Upper Saddle River, NJ: Prentice Hall Inc.
				</TD>
			</TR>
			<TR>
				<TD VALIGN=TOP WIDTH="10%">
					[<A NAME="LEA97">LEA97</a>]
				</TD>
				<TD WIDTH="90%">
					Lea, D. (1997). <I>Concurrent Programming in Java: Design Principles and Patterns</I>. Reading, MA: Addison Wesley Longman Inc.
				</TD>
			</TR>
			<TR>
				<TD VALIGN=TOP WIDTH="10%">
					[<A NAME="MCO93">MCO93</a>]
				</TD>
				<TD WIDTH="90%">
					McConnell, S. (1993). <I>Code Complete: A Practical Handbook of Software Construction</I>. Redmond, WA: Microsoft Press.
				</TD>
			</TR>
			<TR>
				<TD VALIGN=TOP WIDTH="10%">
					[<A NAME="MEY88">MEY88</a>]
				</TD>
				<TD WIDTH="90%">
					Meyer, B. (1988). <I>Object-Oriented Software Construction</I>. Upper Saddle River, NJ: Prentice Hall Inc.
				</TD>
			</TR>
			<TR>
				<TD VALIGN=TOP WIDTH="10%">
					[<A NAME="NAG95">NAG95</a>]
				</TD>
				<TD WIDTH="90%">
				Nagler, J. (1995). <I>Coding Style and Good Computing Practices</I>.
                    http://wizard.ucr.edu/~nagler/coding_style.html
				</TD>
			</TR>
			<TR>
				<TD VALIGN=TOP WIDTH="10%">
					[<A NAME="SUN96">SUN96</a>]
				</TD>
				<TD WIDTH="90%">
					Sun Microsystems (1996). <I>javadoc - The Java API Documentation Generator</I>. Sun Microsystems.
				</TD>
			</TR>
			<TR>
				<TD VALIGN=TOP WIDTH="10%">
					[<A NAME="SUN97">SUN97</a>]
				</TD>
				<TD WIDTH="90%">
					Sun Microsystems (1997). <I>100% Pure Java Cookbook for Java Developers: Rules and Hints for Maximizing the Portability of Java Programs.</I> Sun Microsystems.
				</TD>
			</TR>
			<TR>
				<TD VALIGN=TOP WIDTH="10%">
					[<A NAME="VIS96">VIS96</a>]
				</TD>
				<TD WIDTH="90%">
					Vision 2000 CCS Package and Application Team (1996). <I>Coding Standards for C, C++, and Java</I>.
                    http://v2ma09.gsfc.nasa.gov/coding_standards.html
				</TD>
			</TR>
		</TABLE>
	</CENTER>
</DIV>
</BLOCKQUOTE>
	<HR ALIGN=LEFT>
<H1><font face="Arial" size="4">13&nbsp;&nbsp;&nbsp; </font><A NAME="Glossary"><font face="Arial" size="4">Glossary</font></a> <A HREF="#Top"><IMG ALT="return to Contents" BORDER=0 SRC="images/top.gif" width="26" height="20"></a></H1> 
<BLOCKQUOTE>
	<P> 
	<B>
		100% pure</b>: Effectively a "seal of approval" from Sun that says that a Java applet, application, or package, will run on ANY platform
    that supports the Java VM.
</P>
<P> 
<B>
	Accessor</b>: A member function that either modifies or returns the value of a field. Also known as an access modifier. See
<a href="#Getter">
Getter</a> and <a href="#Setter">Setter</a>.
</P>
<P> 
<B>
	Analysis pattern</b>: A modeling pattern that describes a solution to a
business or domain problem.
</P>
<P> 
<B>
	Antipattern</b>: An approach to solving a common problem, that in time proves to be wrong or highly ineffective.
</P>
<P> 
<B>
	Argument</b>: See <a href="#Parameter">parameter</a>.
</P>
<P> 
<B>
	BDK</b>: Beans Development Kit
</P>
<P> 
<B>
	Block</b>: A collection of zero or more statements enclosed in (curly) braces.
</P>
<P> 
<B>
	Braces</b>: The characters <B>{</B> and <B>}</B>, known as an open brace and a close brace respectively, are used to define the beginning and end of a block.
</P>
<P> 
<B>
	Class</b>: A definition, or template, from which objects are instantiated.
</P>
<P> 
<B>
	Class testing</b>: The act of ensuring that a class and its instances (objects) perform as defined.
</P>
<P> 
<B>
	CMVC</b>: Configuration Management and Version Control
</P>
<P> 
<B>
	Compilation unit</b>: A source code file, either a physical one on disk or a "virtual" one stored in a database, in which classes and interfaces are declared.
</P>
<P> 
<B>
    <a name="Component">
	Component</a></b>: An interface widget such as a list, button, or window.
</P>
<P> 
<B>
	Constant getter</b>: A getter member function that returns the value of a "constant," which may, in turn, be hard coded or calculated if
necessary.
</P>
<P> 
<B>
	Constructor</b>: A member function that performs any necessary initialization when an object is created.
</P>
<P> 
<B>
	Containment</b>: An object contains other objects that it collaborates with to perform its behaviors. This can be accomplished either
by the use of inner classes (JDK 1.1+) or the aggregation of instances of other classes within an object (JDK 1.0+).
</P>
<P> 
<B>
	CPU</b>: Central processing unit
</P>
<P> 
<B>
	C-style comments</b>: A Java comment format, /* &amp; */, adopted from the C/C++ language that can be used to create multiple-line comments. Commonly used to "document out" unneeded or unwanted lines of code during testing.
</P>
<P> 
<B>
	Design pattern</b>: A modeling pattern that describes a solution to a design problem.
</P>
<P> 
<B>
	Destructor</b>: A C++ class member function that is used to remove an object from memory once it's no longer needed. Because Java manages its own memory, this kind of member function is not needed. Java does, however, support a member function
that is similar in concept called <B>finalize()</B>.
</P>
<P> 
<B>
	Documentation comments</b>: A Java comment format, /** &amp; */, that can be processed by <I>javadoc</I> to provide external documentation for a class file. The main documentation for interfaces, classes, member functions, and fields should be written with documentation comments.
</P>
<P> 
<B>
    <a name="Field">
	Field</a></b>: A variable, either a literal data type or another object, that describes a class or an instance of a class. Instance fields describe objects (instances) and static fields describe classes. Fields are also referred to as fields, field variables, and properties.
</P>
<P> 
<B>
	finalize()</b>: A member function that is automatically invoked during garbage collection before an object is removed from memory. The purpose of this member function is to do any necessary cleanup, such as closing open files.
</P>
<P> 
<B>
	Garbage collection</b>: The automatic management of memory, where objects that are no longer referenced are automatically removed from memory.
</P>
<P> 
<B>
    <a name="Getter">
	Getter</a></b>: A type of accessor member function that returns the value of a field. A getter can be used to answer the value of a constant, which is often preferable to implementing the constant as a static field because this is a more flexible approach.
</P>
<P> 
<B>
	HTML</b>: Hypertext markup language, an industry-standard format for creating
Web pages.
</P>
<P> 
<B>
	Indenting</b>: See <a href="#Paragraphing">paragraphing</a>.
</P>
<P> 
<B>
	Inline comments</b>: The use of a line comment to document a line of source code where the comment immediately follows the code, on the same line as the code. Single line comments are typically used for this, although C-style comments can also be employed.
</P>
<P> 
<B>
	Interface</b>: The definition of a common signature, including both member functions and fields, which a class that implements an interface must support. Interfaces promote polymorphism by composition.
</P>
<P> 
<B>
	I/O</b>: Input/output
</P>
<P> 
<B>
	Invariant</b>: A set of assertions about an instance or class that must be true at all "stable"
times, such as the periods before and after the invocation of a member function on the
object or class.
</P>
<P> 
<B>
	Java</b>: An industry-standard, object-oriented development language that is well-suited for developing applications for the Internet and applications that must operate on a wide variety of computing platforms.
</P>
<P> 
<B>
	javadoc</b>: A utility included in the JDK that processes a Java source code file and produces an external document, in HTML format, describing the contents of the source code file based on the documentation comments in the code file.
</P>
<P> 
<B>
	JDK</b>: Java Development Kit
</P>
<P> 
<B>
	Lazy initialization</b>: A technique in which a field is initialized in its corresponding getter member function the first time it's needed. Lazy initialization is used when a field is not commonly needed and it either requires a large amount of memory to store or it needs to be read in from permanent storage.
</P>
<P> 
<B>
	Local variable</b>: A variable defined within the scope of a block, often a member function. The scope of a local variable is the block in which it is defined.
</P>
<P> 
<B>
	Member function</b>: A piece of executable code associated with a class or the instances of a class. Think of a member function as the object-oriented equivalent of a function.
</P>
<P> 
<B>
	Member function signature</b>: See <a href="#Signature">signature</a>.
</P>
<P> 
<B>
	Method testing</b>: The act of ensuring that a member function (member function) performs as defined.
</P>
<P> 
<B>
	Name hiding</b>: This refers to the practice of using the same, or at least
a similar, name for a field, variable, or argument as for one of higher scope. The most common abuse of name hiding is to name a local variable the same as an instance field. Name hiding should be avoided as it makes your code harder to understand and prone to bugs.
</P>
<P> 
<B>
	Overload</b>: A member function is said to be overloaded when it's defined more than once in the same class (or in a
subclass); the only difference being the signature of each definition.
</P>
<P> 
<B>
	Override</b>: A member function is said to be overridden when it is redefined in a subclass and it has the same signature as the original definition.
</P>
<P> 
<B>
	Package</b>: A collection of related classes.
</P>
<P> 
<B>
    <a name="Paragraphing">
	Paragraphing</a></b>: A technique where you indent the code within the scope of a code block by one unit, usually a horizontal tab, so as to distinguish it from the code outside of the code block. Paragraphing helps to increase the readability of your code.
</P>
<P> 
<B>
    <a name="Parameter">
	Parameter</a></b>: An argument passed to a member function, a parameter may be a defined type, such as a string, or an int, or an object.
</P>
<P>
	<B>postcondition</B>: A property or assertion that will be true after a member function is finished running.
</P>
<P>
	<B>precondition</B>: A constraint under which a member function will function properly.
</P>
<P> 
<B>
	Property</b>: See <a href="#Field">field</a>.
</P>
<P> 
<B>
    <a name="Setter">
	Setter</a></b>: An accessor member function that sets the value of a field.
</P>
<P> 
<B>
    <a name="Signature">
	Signature</a></b>: The combination of the type of parameters, if any, and their order that must be passed to a member function.
This is also called the member function signature.
</P>
<P> 
<B>
	Single-line comments</b>: A Java comment format, // , adopted from the C/C++ language that is commonly used for the internal member function documentation of business logic.
</P>
<P> 
<B>
	Tags</b>: A convention for marking specified sections of documentation comments that will be processed by <I>javadoc</I> to produce professional-looking comments. Examples of tags include <I>@see</I> and <I>@author</I>.
</P>
<P> 
<B>
	Test harness</b>: A collection of member functions for testing your code.
</P>
<P> 
<B>
	UML</b>: Unified modeling language, which is an industry-standard modeling notation.
</P>
<P> 
<B>
	Visibility</b>: A technique used to indicate the level of encapsulation of a class, member function, or field. The keywords-public, protected, and private-can be used to define visibility.
</P>
<P> 
<B>
	Whitespace</b>: Blank lines, spaces, and tabs added to your code to increase its readability.
</P>
<P> 
<B>
	Widget</b>: See <a href="#Component">component</a>.
</P>
</BLOCKQUOTE>
<P>

 
 
<div class="margins20">
<p>
 <a href="/copyrite/copyrite.htm">
 <font size="-2">&copy; Copyright IBM Corp. 1987, 2004. All Rights Reserved.</font>
 </a>
</p>
</div>


</td><td valign="top" width="24"></td><td valign="top" width="1%">
<p>
<a href="/index.htm"></a>
</p>

<script language="JavaScript">
<!--

function loadTop()
{
  if(parent.frames.length!=0 && parent.frames[1].name=="ory_toc")
  {
	 var msg = "The Rational Unified Process is already displayed using frames";
     alert(msg);
  }
  else
  {
    var expires = new Date();
    expires.setTime (expires.getTime() + (1000 * 20));
    document.cookie = "rup_ory_doc=" + escape (document.URL) +
    "; expires=" + expires.toUTCString() +  "; path=/";

    var new_ory_doc_loc = null;

    for(i=document.links.length-1;i>=0;i--)
    {
       if(document.links[i].href.indexOf("index.htm")!=-1)
       {
         new_ory_doc_loc = document.links[i].href;
         break;
       }
    }

    if(new_ory_doc_loc!=null)
    {
	if( self.name == "ory_doc" )
	{
		window.close();
		window.open( new_ory_doc_loc );		
	}
	else
	{
	       	top.location = new_ory_doc_loc;
	}
    }
   }
}
// -->
</script>
<script language="JavaScript">
<!--
  function getImageUrl(image)
  {
    var new_ory_doc_loc=null;
    for(i=document.links.length-1;i>=0;i--)
    {
       if(document.links[i].href.indexOf("index.htm")!=-1)
       {
         new_ory_doc_loc = document.links[i].href.substring(0,document.links[i].href.lastIndexOf("/"));
         new_ory_doc_loc = new_ory_doc_loc + "" + image;
         return new_ory_doc_loc;
       }
    }
    return null;
  }
// -->
</script>
<script
language="JavaScript">
<!--
MSFPhover =
(((navigator.appName == "Netscape") &&
  (parseInt(navigator.appVersion) >= 3 )) ||
  ((navigator.appName == "Microsoft Internet Explorer") &&
  (parseInt(navigator.appVersion) >= 4 )));

  function MSFPpreload(img)
  {
     var a=new Image();
     a.src=img;
     return a;
  }
// -->
</script>
<script language="JavaScript">
<!--
    if(MSFPhover)
    {
        RupGray=MSFPpreload(getImageUrl('/images/rup1.gif'));
        RupBlue=MSFPpreload(getImageUrl('/images/rup1_a.gif'));
    }
// -->

//display the load button or not
var ory_toc_exist = typeof parent.ory_toc;
if (ory_toc_exist == "undefined") {
	// split alt text out to allow translation
	var altText = "Display Rational Unified Process using frames";
	document.write("<a href=\"JavaScript:loadTop();\" onmouseover=\"if(MSFPhover) document['Home'].src=RupBlue.src; self.status=' '; return true\" onmouseout=\"if(MSFPhover) document['Home'].src=RupGray.src; self.status= ' ';return true\"> <br> <img src=\"images/rup1.gif");
	document.write("\"  border=\"0\" alt=\"");
        document.write(altText);
        document.write("\" name=\"Home\" width=\"26\" height=\"167\"></a>");

}
else {
	var nbsp = "&nbsp;";
	document.write(nbsp);
}
</script>

</td></tr></table><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td>
<p align="right"><small><small>Rational Unified Process&nbsp;&nbsp; 
<img border="0" alt="2003.06.13" src="images/rupversion.gif">
</small></small>
</td></tr></table>

 


</BODY>
</HTML>
